// Landscape event definition for logging in the 43-02 landscape model
// It is driven by the input variable AAC, which specifies the volume of wood
// to cut per year. Enough cutblocks are laid down to cut the required volume
// Currently Supports the following management options (delineated in the ManagementZone layer)
//    SQ: status quo: harvest a given annual percent, constrained by block size and min. harvest age
//    AC: age class targetted: as SQ, but also attempt to achieve a given age class distribution. This may
//            be secondary (soft) to the harvest request or primary (hard)
//    SC: strip-cutting: as SQ, but cut in 50m wide groups of strips, with rentry to cut the other half
LSEVENT: LOGGING

DEFINITIONS
   /////////////////////////////////////////////////
   // INPUT STATE - constants and parameters
   /////////////////////////////////////////////////
   GLOBAL CONSTANT: HaPerCell, CellWidth, MaxStandAge
   GLOBAL CONSTANT: NumAgeClasses, ACSize
   LAYER: StudyArea, LandUnit, AU

   // Zones in which different management regimes will apply
   LAYER: ManagementZone
   GLOBAL CONSTANT: NumManagementZones, rAC, rStripCut, rEM, rIM

   GLOBAL VARIABLE: BaseTimestep // Base Time step (in years)
   GLOBAL VARIABLE: AreaBasedHarvest // If TRUE use area vs. volume based harvest (AAC specifies hectares not m3 to cut)
   GLOBAL VARIABLE: PercentBasedHarvest // If TRUE, interpret AAC a a percent of total area/volume available
   GLOBAL CONSTANT: AUInfo[], rMHA
   GLOBAL VARIABLE: MHA_Override

   // Length of time for greenup constraints (default: 15 years)
   // Prob. of logging in an adjacency buffer (set to zero for hard adjacency)
   GLOBAL VARIABLE: GreenupYears, pLogInBuffer

   // Strip cutting parameters
   GLOBAL VARIABLE: StripCutWidth


   // Range between start of deline in prob.
   // The maximum distance from road for harvesting is assumed to be 2000m. Set higher (along with MinNoEffectDist2Rd) to remove access restrictions.
   GLOBAL VARIABLE: MinNoEffectDist2Rd, MaxDist2Road

   // Minimum yield that will be harvested in m3 per ha
   GLOBAL CONSTANT: MinYieldSalvagePerHa

   // AAC in hectares or m3, set up in intervals
   GLOBAL CONSTANT: AAC[], MaxAACDecade

   // Multiply AAC by this...
   GLOBAL VARIABLE: AACMult

   // Increase growth in IM by this... (in lieu of having volume tables)
   GLOBAL VARIABLE: IMGrowthIncreaseFactor

   // Usually 50ha
   GLOBAL VARIABLE: BlockSizeMin, BlockSizeMax
   LAYER: MaxPotBlockSize // Mar 2010: contains that maximum potential block size for each cell


   // CONSTRAINTS for AC scenarios
   GLOBAL CONSTANT: AgeClassTargets[]
   GLOBAL VARIABLE: ACType
   GLOBAL CONSTANT: rACStrictLocal, rACStrictReserveOlder, rACProbabilistic

   /////////////////////////////////////////////////
   // INPUT STATE - INTERNAL (computed in initial state)
   /////////////////////////////////////////////////
   LOCAL: UseSoftAdjacency, DistanceEffectSlope

   /////////////////////////////////////////////////
   // INPUT STATE - dynamic in other events
   /////////////////////////////////////////////////
   LAYER: Species, StandType
   LAYER: VolPerHa, SalvageableVolume // in 10ths of a cubic metre
   GLOBAL CONSTANT: Salvageable
   GLOBAL VARIABLE: VolumeUnsalvaged[]

   LAYER: PotentialTreatmentType, OperatingArea //, ProbLog
   GLOBAL CONSTANT: Unavailable, SalvageBlock, VolScale

   LAYER: LastDisturbance 
   GLOBAL CONSTANT: rFire

   // CONSTRAINTS for AC scenarios
   GLOBAL VARIABLE: ForestSizeByZone[], GrowingStockByZone[]

   LAYER: NearestRoadSegment, RoadType, RoadBackbone, DistFromExit

   /////////////////////////////////////////////////
   // FEEDBACK STATE
   /////////////////////////////////////////////////
   LAYER: StandAge

   LAYER: Logged, BlockId  // Time since logging is MaxTimeSinceDisturbance - Logged
   GLOBAL CONSTANT: MaxTimeSinceDisturbance

   LAYER: Dist2ActiveRds, NearestRoadLoc

   // Road types
   GLOBAL CONSTANT: newlyActiveRoad, reactivatedRoad, newlyActiveSpur

   // For tracking roads built
   GLOBAL VARIABLE: KmRoadsBuilt[], KmPerM3Hauled[]

   // Road segment list
   GLOBAL CONSTANT: rState
   GLOBAL VARIABLE: RoadSegmentTable[]

   EVENT VARIABLE: EventExtent, OpeningsLeft, currBlockId
   EVENT VARIABLE: HarvestTarget
   CLUSTER VARIABLE: OpeningExtent, SalvageLogging, blockLU, blockId, currOA, yearInPeriod
   CLUSTER VARIABLE: currBlockSize, NumActiveLoggingCells, currRoadSegment, stripCutEntry, stripCutStartCol, stripCutLogged

   CELL VARIABLE: NearestRoadLocation, NewDistanceFromRoad, StillLogging
   CELL VARIABLE: Yield

   // MANAGEMENT TYPE
   EVENT VARIABLE: managementType

   // For AC scenarios
   GLOBAL VARIABLE: SizeByYearZone[], SizeByClassZone[], SurplusByYear[], SurplusByAC[]


   /////////////////////////////////////////////////
   // OUTPUT STATE
   /////////////////////////////////////////////////

   // Amount and area cut in year 
   GLOBAL VARIABLE: VolHarvestedForYear[], AreaHarvestedForYear[], AreaAccessedForYear, AnnualHarvestTarget, SumOfAgeForYear[]
   GLOBAL VARIABLE: VolumeHarvestedByZone[], AreaHarvestedByZone[], AreaAccessedByZone[], AgeHarvestedByZone[], AreaHarvestedByStandType[], AnnualHarvestTargetByZone[]

   // Harvest profile tracked by species
   GLOBAL VARIABLE: HarvestProfile[]
   GLOBAL CONSTANT: SppLookup[]

   // Block size class distribution reporting
   GLOBAL CONSTANT: BlockClassSize, NumBlockClasses//, MaxBlockSize   RT activated on the advice of Andrew
   GLOBAL VARIABLE: BlockSizeDist[], BlockSizeArea[]               //RT activated on the advice of Andrew
ENDDEF


INITIALSTATE
   UseSoftAdjacency = (GreenupYears > 0) AND (pLogInBuffer > 0)
   DistanceEffectSlope = IF (MaxDist2Road > MinNoEffectDist2Rd) THEN 1 / (MinNoEffectDist2Rd - MaxDist2Road) ELSE 0

   INITIALSTATE = NumManagementZones
   managementType = EventId
ENDIS


RETURNTIME
   RETURNTIME = IF Time EQ 0 THEN 0.8 ELSE BaseTimestep
   // Process IN LAST YEAR OF PERIOD so that all harvesting for preceding period can be processed
//   RETURNTIME = IF Time EQ 0 THEN 0.8 + BaseTimestep-1 ELSE BaseTimestep
//   RETURNTIME = IF (Time EQ 0) THEN 0.8 ELSE ((ForestSizeByZone[managementType] > 0) AND (AAC[managementType, applicableDecade] > 0)) * BaseTimestep

   currBlockId = 1
ENDRT


// Only log in forested cells in the THLB
EVENTLOCATION
   STATIC REGION WHOLE MAP
     DECISION (StudyArea > 0) AND (Species > 0) //AND (ManagementZone EQ managementType) // dynamic
ENDEL


NUMCLUSTERS
   // Determine harvest target for time period
   // NOTE: Any active natural distrubance sub-models will individually reduce the NRL portion of the AAC
    // (Effectively, using the new NRLs increment the AAC ("creative" way to bump up the AAC?)
   applicableDecade = MIN(FLOOR(Time/10), MaxAACDecade)
   HarvestTarget = IF (ForestSizeByZone[managementType] > 0) THEN AAC[managementType, applicableDecade] * AACMult ELSE 0

   IF PercentBasedHarvest
      HarvestTarget = IF AreaBasedHarvest THEN (HarvestTarget/100) * (ForestSizeByZone[managementType]*HaPerCell)
                      ELSE (HarvestTarget/100) * GrowingStockByZone[managementType]
   END

   HarvestTarget = HarvestTarget * BaseTimestep
   AnnualHarvestTarget = AnnualHarvestTarget + HarvestTarget
   AnnualHarvestTargetByZone[managementType] = HarvestTarget

   // Keep creating clusters (blocks) as long as the harvest target is not met (and there are still 
   // available cells to initiate in)
   // Each cutblock is logged immediately (spread time is -2) when it is started.
   // That is, all the spreading will occur BEFORE the next cut block is started.
   NUMCLUSTERS = WHILE HarvestTarget > 0

   // Check if this is salvage
   SalvageLogging = (PotentialTreatmentType EQ SalvageBlock)

   // Each opening is uniformly distributed in input range
   OpeningExtent = UNIFORM(BlockSizeMin/HaPerCell, BlockSizeMax/HaPerCell)

   currBlockSize = 0
   NumActiveLoggingCells = 0 // Mar 2010: added to initiate properly
   OpeningExtent = ROUND(OpeningExtent)

   // Determine strip cut entry: entry 2 if a neighbour one strip away, in same block, is immature
   stripCutEntry = 1
   IF (!SalvageLogging) AND (managementType EQ rStripCut) AND (0 < Logged < (MaxTimeSinceDisturbance - BaseTimestep + 1))
      nYoung = 0
//      n = 0
      d = ROUND(StripCutWidth/CellWidth)
      OVER REGION CENTRED(d,d, CARDINAL)
         DECISION ((Logged EQ SOURCE Logged) AND (StandAge < AUInfo[AU,rMHA]))
         nYoung = nYoung + 1
//         n = n + 1
//         nYoung = nYoung + ((Logged EQ SOURCE Logged) AND (StandAge < AUInfo[AU,rMHA]))
      END
      stripCutEntry = 1 + (nYoung > 0)
   END
   stripCutStartCol = COL(Location)
   stripCutLogged = Logged

   IF (stripCutEntry EQ 2)
      blockId = BlockId
   ELSE
      blockId = currBlockId
      currBlockId = (currBlockId % 100) + 1
   END
   currOA =OperatingArea

  // Pick a year for the harvest (to avoid all stands ending up on "BaseTimestep" lines)
//  yearInPeriod = MIN(FLOOR(UNIFORM(0, BaseTimestep)), BaseTimestep-1)                   RT deactivated this line
ENDNC


// Assumes that the Cell Availability sub-model has run to determine which cells 
// are available for harvest at the start of this time period
PROBINIT ORDERED
   Logged = MAX(Logged-BaseTimestep, 0)

   // Probability based on distance
   pDistance = IF Dist2ActiveRds <= MinNoEffectDist2Rd THEN 1 
               ELSE MAX(0,1 + (Dist2ActiveRds-MinNoEffectDist2Rd)*DistanceEffectSlope)

   // Are we in an adjacency buffer?  Only test for soft adjacency for available cells
   inBuffer = FALSE
   IF (PotentialTreatmentType > Unavailable) AND (UseSoftAdjacency) AND (GreenupYears > 0)
      OVER REGION CENTRED(1, 1.5, EUCLIDEAN)
         inBuffer = inBuffer OR (StandAge <= GreenupYears)
      END
   END
 
   EffectiveAge =  IF ManagementZone EQ rIM THEN StandAge * IMGrowthIncreaseFactor ELSE StandAge

   // NOTE: These probabilities are computed at the start of the logging year and do not reflect 
   // changes as harvesting progresses.  Hence, to avoid violations may occur within a year for a 
   // zone near but not over its constraint limits, a check is made again in TRANSITIONS
   pLog = PRODUCT
            ManagementZone EQ managementType  // To handle dynamic changes, process here (vs. in EventLocation)
            PotentialTreatmentType > Unavailable
            AU > 0

            MaxPotBlockSize >= BlockSizeMin // Mar 2010: don't allow selection of cells that won't support blocks of at least the min. size

             // If this is a naturally disturbed cell with salvageable timber...
             IF PotentialTreatmentType EQ SalvageBlock
             THEN (10 * (SalvageableVolume/MinYieldSalvagePerHa))

             // Otherwise, this is a green cell...
             ELSE PRODUCT
                     // Relative oldest first
                     (StandAge/MAX(1,AUInfo[AU,rMHA]))
//                     (StandAge - AUInfo[AU,rMHA] + 1)
//                     EffectiveAge

                     // Target Operating areas
                     IF OperatingArea > 0 THEN 1000 ELSE 1

                     // For probabilistic age class scenario
                     IF (managementType EQ rAC) AND (ACType EQ rACProbabilistic)
                     THEN 1 + 5*(SurplusByYear[StandAge])
                     ELSE 1

                     // Decrease probability in adjacency buffers
                     IF inBuffer THEN pLogInBuffer ELSE 1
                  END

             pDistance
          END

//   ProbLog = CLAMP(pLog, 0,100)

   PROBINIT = pLog

   NearestRoadLocation = Location
   StillLogging = (HarvestTarget > 0) AND (Logged < (MaxTimeSinceDisturbance - BaseTimestep + 1))
   blockLU = LandUnit
   currRoadSegment = NearestRoadSegment
ENDPI



TRANSITIONS
   // FIRST: Update "still logging" flag
   // Check if we should still be logging. This must be done to avoid logging a cell that is in a constraining zone.
   // This may occur during spread, and also for the first cell of a new block (in which case,we must also create an empty opening)

   IF StillLogging
      // There is still extent left in the clearcut and volume to harvest
//      isAvailable = (OpeningExtent >= 1) AND (HarvestTarget > 0) AND (AUInfo[AU,rMHA] > 0)
      isAvailable = IF (stripCutEntry EQ 2) THEN (HarvestTarget > 0) AND (Species > 0) AND (PotentialTreatmentType > Unavailable)
                    ELSE (OpeningExtent >= 1) AND (HarvestTarget > 0) AND (Species > 0) AND (PotentialTreatmentType > Unavailable)
//      isAvailable = (OpeningExtent >= 1) AND (HarvestTarget > 0) AND (Species > 0) AND (PotentialTreatmentType > Unavailable)
      EffectiveAge =  IF ManagementZone EQ rIM THEN StandAge * IMGrowthIncreaseFactor ELSE StandAge

      // For Salvage Logging, only allow salvage and only for last partition ...
      IF SalvageLogging
         isAvailable = isAvailable AND (SalvageableVolume > MinYieldSalvagePerHa)
         isMature = FALSE // Mar 2010: added for completeness (won't affect model)
      ELSE
         // AC target 
         IF (managementType EQ rAC)
            ageClass = MIN(FLOOR(StandAge / ACSize), NumAgeClasses-1)
            isAvailable = isAvailable AND ((ACType EQ rACProbabilistic) OR ((SurplusByYear[StandAge] > 0) AND (SurplusByAC[ageClass] > 0)))
         END

         // Are we in an adjacency buffer?  Only test for soft adjacency
         inBuffer = FALSE
         IF (UseSoftAdjacency) AND (GreenupYears > 0)
            OVER REGION CENTRED(1, 1.5, EUCLIDEAN)
               inBuffer = inBuffer OR (StandAge <= GreenupYears)
            END
         END

         // MHA and First year. Use look ahead if enabled
         mha = IF (MHA_Override > 0) THEN MHA_Override ELSE AUInfo[AU,rMHA]
         isMature = EffectiveAge >= mha
         isAvailable = isAvailable AND isMature

         // Adjacency
         isAvailable = isAvailable AND ((UseSoftAdjacency) OR (!inBuffer))
      END

      // Finally: we know if this cell is available
//      StillLogging = ((stripCutEntry EQ 2) AND (!isMature) AND (OpeningExtent >= 1)) OR isAvailable
      StillLogging = ((stripCutEntry EQ 2) AND (!isMature)) OR isAvailable
   END


   // Second: If we are still logging, change logged cells
   // Do this before main expression so we can re-use the local id variables computed above (we still know that this cell will "occur")
   IF StillLogging
      cutCell = IF (managementType EQ rStripCut) 
                THEN IF (stripCutEntry EQ 1) 
                   THEN IF COL(Location) >= stripCutStartCol
                        THEN (((COL(Location)-stripCutStartCol) % (2*StripCutWidth/CellWidth)) < ROUND(StripCutWidth/CellWidth))
                        ELSE (((stripCutStartCol-COL(Location)) % (2*StripCutWidth/CellWidth)) >= ROUND(StripCutWidth/CellWidth))
//                   THEN (((COL(Location)-stripCutStartCol) % (2*StripCutWidth/CellWidth)) < ROUND(StripCutWidth/CellWidth))
//                     THEN ((COL(Location) % (2*StripCutWidth/CellWidth)) < ROUND(StripCutWidth/CellWidth))
                     ELSE isAvailable
                ELSE TRUE
/*DISPLAY
? (!cutCell) AND (StandAge > 150) AND (stripCutEntry EQ 2)
cutCell
StandAge
StillLogging
isMature
inBuffer
HarvestTarget 
av: PotentialTreatmentType > Unavailable
END
DISPLAY
? (StandAge < 50) AND (stripCutEntry EQ 1)
a:0
cutCell
StandAge
StillLogging
isMature
inBuffer
HarvestTarget 
av: PotentialTreatmentType > Unavailable
END
 */
     NumActiveLoggingCells = NumActiveLoggingCells + 1

      // Determine the volume
      Yield = (VolPerHa * HaPerCell + SalvageableVolume)/VolScale

      IF cutCell
         // Update salvaged volume
         IF SalvageableVolume > 0
            VolumeSalvaged = VolumeSalvaged + SalvageableVolume
            lastDisturbanceAgent = IF (LastDisturbance > 0) THEN LastDisturbance ELSE rFire
            VolumeUnsalvaged[lastDisturbanceAgent,Salvageable] = VolumeUnsalvaged[lastDisturbanceAgent,Salvageable] - SalvageableVolume

            // Reset the salvage volume
            SalvageableVolume = 0
         END
      END

      // Decrement the number of cells remaining to burn for this opening
      OpeningExtent = OpeningExtent - 1
      Logged = MaxTimeSinceDisturbance //- yearInPeriod                   RT took out -yearinperiod
      BlockId = blockId
//      LastDisturbance = rLogged

      // Increment the yearly volume and areas harvested
      IF cutCell
         AreaId = SalvageLogging
         VolHarvestedForYear[AreaId] = VolHarvestedForYear[AreaId] + Yield
         AreaHarvestedForYear[AreaId] = AreaHarvestedForYear[AreaId] + HaPerCell 
         SumOfAgeForYear = SumOfAgeForYear + StandAge

         VolumeHarvestedByZone[ManagementZone] = VolumeHarvestedByZone[ManagementZone] + Yield
         AreaHarvestedByZone[ManagementZone] = AreaHarvestedByZone[ManagementZone]+ HaPerCell
         AreaAccessedByZone[ManagementZone] = AreaAccessedByZone[ManagementZone] + HaPerCell
         AgeHarvestedByZone[ManagementZone] = AgeHarvestedByZone[ManagementZone] + StandAge

         lead = SppLookup[Species, 0]
//         HarvestProfile[lead] = HarvestProfile[lead] + HaPerCell  // area-based
         HarvestProfile[lead] = HarvestProfile[lead] + Yield

         HarvestTarget = IF AreaBasedHarvest THEN HarvestTarget - HaPerCell
                         ELSE HarvestTarget - Yield

         KmPerM3Hauled[ManagementZone] = KmPerM3Hauled[ManagementZone] + (DistFromExit/1000)*Yield
      END
      AreaAccessedForYear = AreaAccessedForYear + HaPerCell

       // Set nearest road location to this cell
      NewDistanceFromRoad = CellWidth * DISTANCE(Location, NearestRoadLocation)

      // If this is an initiating cell: create a spur
      IF currBlockSize EQ 0
         // Activate nearest road segment
         IF RoadSegmentTable[NearestRoadSegment, rState] EQ 0
            RoadSegmentTable[NearestRoadSegment, rState] = newlyActiveRoad // newly activated
         ELSE
            RoadSegmentTable[NearestRoadSegment, rState] = reactivatedRoad // reactivated
         END

         // Create a spur road (just use straight-line) except for heli-aus
         IF (RoadType EQ 0) 
            IF (NearestRoadLoc <= 0) // but for islands, just put a "dock" here
               KmRoadsBuilt[newlyActiveSpur] = KmRoadsBuilt[newlyActiveSpur] + (CellWidth/1000)
               NearestRoadLoc = Location
               RoadType = newlyActiveSpur
            ELSE
               KmRoadsBuilt[newlyActiveSpur] = KmRoadsBuilt[newlyActiveSpur] + DISTANCE(Location, NearestRoadLoc) * (CellWidth/1000)
               OVER REGION VECTOR(Location, NearestRoadLoc)
                  DECISION (RoadType EQ 0) AND (RoadBackbone NEQ 1)
                  NearestRoadLoc = Location
                  RoadType = newlyActiveSpur
               END
            END
         END
      END

      IF cutCell
         oldAgeClass = MIN(FLOOR(StandAge/ACSize), NumAgeClasses-1)
         IF (StandAge > ACSize)
            SizeByClassZone[oldAgeClass, managementType] = SizeByClassZone[oldAgeClass, managementType] - HaPerCell
            SizeByClassZone[0, managementType] = SizeByClassZone[0, managementType] + HaPerCell
         END

         /* Update age summary information */
         SizeByYearZone[StandAge, managementType] = SizeByYearZone[StandAge, managementType] - HaPerCell
         SizeByYearZone[0, managementType] = SizeByYearZone[0, managementType] + HaPerCell
         AreaHarvestedByStandType[StandType] = AreaHarvestedByStandType[StandType] + HaPerCell

         IF (managementType EQ rAC)
            SurplusByYear[StandAge] = SurplusByYear[StandAge] - HaPerCell

            ageClass = MIN(FLOOR(StandAge / ACSize), NumAgeClasses-1)
            SurplusByAC[ageClass] = SurplusByAC[ageClass] - HaPerCell
         END

         // Set the stand age
         StandAge = 0 // RT changed to 0 from yearInPeriod // Don't just set to 0, since base time step may be > 1
         IF currOA > 0
            OperatingArea = currOA
         END
      END

      currBlockSize = currBlockSize + HaPerCell
      continue = TRUE

   // finished logging
   ELSE IF (currBlockSize > 0) // Not still logging (don't do anything in an "empty" block)
      NewDistanceFromRoad = CellWidth * DISTANCE(Location, NearestRoadLocation)    // Update dist to road layer after a block is finished
      continue = (NewDistanceFromRoad < Dist2ActiveRds) AND (NewDistanceFromRoad <= MaxDist2Road)

   ELSE // empty blocks
      continue = FALSE
   END

   // Make a transition only if we are still logging or still updating the distance from road layer
   TRANSITIONS = continue

   // Update the Distance from Road layer
   Dist2ActiveRds = NewDistanceFromRoad
   NearestRoadLoc = NearestRoadLocation
ENDTR


// Spread immediately
SPREADTIME
   SPREADTIME = -1

  IF StillLogging
     NumActiveLoggingCells = NumActiveLoggingCells - 1
  END
ENDST

// Spread to cardinal neighbours (even outside study area, so that block termination
// can be detected in one place)
SPREADLOCATION
   REGION CENTRED(1,1.5) //Mar 2010: to eight neighbours, at least 1 cell and at most 1.5 cells away
      DECISION (StudyArea > 0) AND (Logged < (MaxTimeSinceDisturbance - BaseTimestep + 1))
ENDSL


SPREADPROB
   // Keep spreading: transitions will stop when the cutblock is finished
//   SPREADPROB = 1
   SPREADPROB = IF OperatingArea > 0 THEN 1000 ELSE 1 // Target Operating areas

    // Transfer "still logging" status from source cell and we are in the THLB and in same operating area (not latter: pattern issues)
    // Except if the front is large, the spread randomly
   IF (SOURCE StillLogging) AND (Species > 0) AND (ManagementZone EQ managementType) //AND (OperatingArea EQ SOURCE OperatingArea)
      IF (stripCutEntry EQ 2)
         StillLogging = (Logged EQ stripCutLogged) AND (BlockId EQ blockId)
      ELSE
         StillLogging = (NumActiveLoggingCells < 20) OR (UNIFORM(0,1) < 0.5) // Mar 2010: changed prob. from 0.1 to 0.5 to make more regular, and min active cells from 10 to 20
      END
   ELSE
      StillLogging = FALSE
   END
   NearestRoadLocation = IF (NearestRoadLoc EQ Location) THEN Location ELSE SOURCE NearestRoadLocation
ENDSP

// Mar 2010: added EndCluster property to simplify block size reporting and to fix block shape
ENDCLUSTER
   // This is the last active cell in the block (i.e. the block is ending)  RT activated this on Andrew's advice
   IF (currBlockSize  > 0)
      blockClass = MIN(FLOOR(currBlockSize / BlockClassSize), NumBlockClasses-1)
      BlockSizeDist[blockClass,blockLU] = BlockSizeDist[blockClass,blockLU] + 1
      BlockSizeArea[blockClass,blockLU] = BlockSizeArea[blockClass,blockLU] + currBlockSize
   END

   ENDCLUSTER = TRUE
ENDEC
