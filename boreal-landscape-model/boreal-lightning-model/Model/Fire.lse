// Empirical fire model for boreal forested landscapes
// Can be parameterized to run as a "simple empirical" size-based (top-down) model based on number and size of fires,
// or as a "more complex somewhat process-based" (bottom-up) model based on number and duration of fires and fuel.
// In the former, "fire size" paramtes are used; in the latter "fire duration" (in days) parameters are used.
LSEVENT: Fire

DEFINITIONS
   /////////////////////////////////////////////////
   // INPUT STATE - constants and parameters
   /////////////////////////////////////////////////
   GLOBAL CONSTANT: HaPerCell, CellWidth, NumLandUnits, FuelConstants[]
   GLOBAL VARIABLE: BaseTimestep // Base Time step (in years)

   // Fire Parameters
   GLOBAL VARIABLE: FireModelType, MinISI, MaxISI, MeanISI // controls whether the model uses simple empirical or complex fires
   GLOBAL CONSTANT: rSizeBasedFire, rDurationBasedFire

   GLOBAL VARIABLE: ApplyFireFuelEffect // If TRUE, use estimated fuel types to affect initiation and spread
   GLOBAL VARIABLE: ApplyFireLandUnitEffect // If TRUE, pick initiation points based on MFRI for the land unit

   GLOBAL VARIABLE: FireMeanNumPerDecade, FireMeanSize, FireMaxSize
   GLOBAL VARIABLE: FireMeanDuration, FireMaxDuration
   //GLOBAL VARIABLE: FuelEffect, FuelEffectProb
   GLOBAL VARIABLE: FireProbUnburned[]

   // LandUnit in rows , parameters in columns
   GLOBAL CONSTANT: LandUnitInfo[], rFireReturnInterval

   LAYER: StudyArea, LandUnit, Ecoregion, ManagementZone

   /////////////////////////////////////////////////
   // INPUT STATE - dynamic in other events
   /////////////////////////////////////////////////
   LAYER: Species, Species2, PctCohort2
   GLOBAL VARIABLE: LUSize[]

   /////////////////////////////////////////////////
   // FEEDBACK STATE
   /////////////////////////////////////////////////
   LAYER: VolPerHa
   GLOBAL CONSTANT: VolScale

   /////////////////////////////////////////////////
   // OUTPUT STATE
   /////////////////////////////////////////////////
   LAYER: LastDisturbance,  FBPFuels // type of last disturbance
   GLOBAL CONSTANT: rFire

   // Shows areas recently burned and potential salvageable
   LAYER: Burnt
   GLOBAL CONSTANT: MaxTimeSinceDisturbance

   LAYER: SalvageableVolume

   LOCAL: minMFRI, meanMFRI, sumMFRI

   EVENT VARIABLE: numberIgnitions
   CLUSTER VARIABLE: targetSize, actualSize, remSize
   CLUSTER VARIABLE: targetDuration, endBurnTime, startBurnTime
   CLUSTER VARIABLE: frontSize, yearInPeriod, ISI, initFuel, initRegion

   CELL VARIABLE: TimeToBurnCell, FireIntensity, srcFireIntensity, FireClass
   CELL VARIABLE: isBurning, srcIsBurning

   CONSTANT: stepTime = 0.0000001 
  
   // Reporting variables
   GLOBAL VARIABLE: VolumeUnsalvaged[]
   GLOBAL CONSTANT: Salvageable, Lost

   GLOBAL VARIABLE: VolumeBurnedByZone[], AreaBurnedByZone[], AreaBurnedByLandUnit[]

   GLOBAL VARIABLE: VolDisturbed[], AreaDisturbed[], NumDisturbPatches[], SelectedAreaDisturbed[], NumSelectedDisturbPatches[]
   GLOBAL CONSTANT: rTotalDisturbed, rForestDisturbed

   // Fire reporting
   OUTPUT VARIABLE: fFireRate = fireRate.txt
ENDDEF

INITIALSTATE
   INITIALSTATE = 1

   // Set up fire parameters once at the start
   minMFRI = 0
   sumMFRI = 0
   n = 0
   OVER INDEX(0,NumLandUnits-1)
      minMFRI = IF (minMFRI EQ 0) THEN LandUnitInfo[Index, rFireReturnInterval]
                ELSE IF (LandUnitInfo[Index, rFireReturnInterval] EQ 0) THEN minMFRI
                ELSE MIN(minMFRI, LandUnitInfo[Index, rFireReturnInterval])
      IF (LandUnitInfo[rFireReturnInterval, Index] > 0)
         sumMFRI = sumMFRI + LandUnitInfo[Index, rFireReturnInterval] * LUSize[Index]
         n = n + LUSize[Index]
      END
   END
   meanMFRI = sumMFRI/n
ENDIS


RETURNTIME
   RETURNTIME = IF (Time EQ 0) THEN 0.7 ELSE BaseTimestep 

   // Clear tracking variables
   VolumeBurnedByZone [=] 0
   AreaBurnedByZone [=] 0
   AreaBurnedByLandUnit [=] 0

   VolDisturbed[rFire] = 0
   AreaDisturbed[rFire,rTotalDisturbed] = 0
   AreaDisturbed[rFire,rForestDisturbed] = 0

   NumDisturbPatches[rFire] = 0
   VolumeUnsalvaged[rFire, Lost] = 0
   SelectedAreaDisturbed[rFire] = 0

   // Update time since disturbance information
   // Need to do this here, since Burnt may include non-forested cells
   OVER REGION WHOLE MAP
      DECISION Burnt > 0
      Burnt = MAX(0,Burnt - BaseTimestep)
   END
ENDRT

// Only ignite in forested cells
EVENTLOCATION
  STATIC REGION WHOLE MAP
     DECISION (Species > 0) AND (StudyArea > 0)
ENDEL

// Start the number of ignitions from a Poisson distribution
NUMCLUSTERS
   // If the mean is large, POISSON won't work (or will take a long time). In these cases, NegExp is a reasonable approximation.
   numberIgnitions = ROUND(POISSON(FireMeanNumPerDecade*BaseTimestep/10))
//   numberIgnitions = ROUND(NEGEXP(FireMeanNumPerDecade*BaseTimestep/10))
   NumSelectedDisturbPatches[rFire] = numberIgnitions

   NUMCLUSTERS = numberIgnitions

   // For each ignition..
   frontSize = 1
   NumDisturbPatches[rFire] =  NumDisturbPatches[rFire] + 1

   // Calculate mean fire Size or Duration (depending on fire model type)
   targetSize = 0 
   targetDuration = 0
   IF (FireModelType EQ rSizeBasedFire)
      // Pick a target size. Restrict fires to greater than 200 ha - mean size paramaterized from "Large Fire Database". PJ
      meanExtent = FireMeanSize /HaPerCell
      WHILE (targetSize <= 200) OR (targetSize > FireMaxSize)
         targetSize = ROUND(NEGEXP(meanExtent))
      END

   ELSE // Duration-Based Fire 
      // Pick a target duration - restrict values of fireSize to be large.
      meanDuration = FireMeanDuration/(CellWidth/100) 
      WHILE (targetDuration < 200) OR (targetDuration > FireMaxDuration)
         targetDuration = ROUND(NEGEXP(meanDuration))
      END
   END

   remSize = targetSize
   SelectedAreaDisturbed[rFire] = SelectedAreaDisturbed[rFire] + targetSize*HaPerCell

   // Calculate the start and end burn time
   startBurnTime = Time
   endBurnTime = Time + (stepTime * targetDuration)
  
   // Pick ISI value (weather) for this fire from continuous distribution.
   // Restrict ISI to be large - i.e., within the realm of large crown fires.
   ISI = 0
   WHILE ((ISI <= MinISI) OR (ISI > MaxISI))
      ISI = ROUND(NEGEXP(MeanISI))
   END
     
   // Pick a year for the fire (to avoid all stands ending up on "BaseTimestep" lines)
   yearInPeriod = MIN(FLOOR(UNIFORM(0, BaseTimestep)), BaseTimestep-1)

   actualSize = 0
   initRegion = Ecoregion 
   initFuel = FBPFuels

   isBurning = TRUE
   srcIsBurning = TRUE

   // Assign intial fire intensity
   srcFireIntensity = 1
ENDNC

PROBINIT
   IF ApplyFireFuelEffect 
      // Global ISI value to calculate probinit, based on fuels.
      gISI = 30

      // Calculate Fuels effect on ignitiion probability
      IF (FBPFuels <= 5) OR (FBPFuels >= 9)
         a = FuelConstants[FBPFuels,0]
         b = FuelConstants[FBPFuels,1]
         c = FuelConstants[FBPFuels,2]
         RSI = a * (( 1 - EXP(-1*b*gISI))^c )
      ELSE IF (FBPFuels EQ 6)   
         RSI = 0.001
      ELSE //(FBPFuels EQ 7) OR (FBPFuels EQ 8)
         a1 = FuelConstants[0,0]
         b1 = FuelConstants[0,1]
         c1 = FuelConstants[0,2]

         a3 = FuelConstants[2,0]
         b3 = FuelConstants[2,1]
         c3 = FuelConstants[2,2]
 
         RSI1 = a1 * (( 1 - EXP(-1 * b1 * gISI) )^c1 ) // RSI for conif (C2)
         RSI3 = a3 * (( 1 - EXP(-1 * b3 * gISI) )^c3 ) // RSI for decid (D1)
         RSI = IF (FBPFuels EQ 7) 
               THEN (0.35*RSI1) + (0.65*RSI3)
               ELSE (0.7*RSI1) + (0.3*RSI3)
      END
 
      // Calculate fuel effect
      FuelEffect = (LOG(RSI)/4.31)  //4.31 = max LOG(RSI) at ISI=30 -  scales to between 0 and 1.
   ELSE
      FuelEffect = 1 // no effect
   END

   // Determine LandUnit effect
   landUnitEffect = IF ApplyFireLandUnitEffect EQ FALSE THEN 1 // not effect
                    ELSE IF LandUnitInfo[LandUnit, rFireReturnInterval] EQ 0 THEN 0 
                    ELSE MIN(1,minMFRI/LandUnitInfo[LandUnit, rFireReturnInterval])

   PROBINIT = FuelEffect * landUnitEffect
ENDPI

TRANSITIONS

   // Initialize FireIntensity
   FireIntensity = 0

   // Calculate Fire Intensity (only for unburned, but burnable cells)
   IF (FBPFuels > 0) AND (Burnt < (MaxTimeSinceDisturbance - BaseTimestep + 1))

      // Determine FBP fuel effect on initial rate of spread (RSI)
      IF (FBPFuels <= 5) OR (FBPFuels >= 9)
         a = FuelConstants[FBPFuels,0]
         b = FuelConstants[FBPFuels,1]
         c = FuelConstants[FBPFuels,2]
         RSI = a * (( 1 - EXP(-1*b*ISI))^c )
      ELSE IF (FBPFuels EQ 6)   
         RSI = 0.001
      ELSE //(FBPFuels EQ 7) OR (FBPFuels EQ 8)
         a1 = FuelConstants[0,0]
         b1 = FuelConstants[0,1]
         c1 = FuelConstants[0,2]

         a3 = FuelConstants[2,0]
         b3 = FuelConstants[2,1]
         c3 = FuelConstants[2,2]

         RSI1 = a1 * (( 1 - EXP(-1 * b1 * ISI) )^c1 ) // RSI for conif (C2)
         RSI3 = a3 * (( 1 - EXP(-1 * b3 * ISI) )^c3 ) // RSI for decid (D1)

         RSI = IF (FBPFuels EQ 7) 
               THEN (0.35*RSI1) + (0.65*RSI3)
               ELSE (0.7*RSI1) + (0.3*RSI3)
      END

      // Calculate fuel effect
      FuelEffect = (LOG(RSI))/4.55  //5.7     // Max RSI AT (ISI = 5) - the mean from the exponential distribution used.
                               // 63% of expected ISI values will be below 5.
      
      // Calculate landunit (duff) effect
      landUnitEffect = IF LandUnitInfo[LandUnit, rFireReturnInterval] EQ 0 THEN 0 
                       ELSE MIN(1,minMFRI/LandUnitInfo[LandUnit, rFireReturnInterval])

      // Calculate expected intensity
      expectedIntensity = FuelEffect * landUnitEffect 

      // Select actual fire intensity from distribution
      FireIntensity = CLAMP(NORMAL(expectedIntensity, 0.2), 0, 1)

      // Calculate geometric mean of source and sink cells
      FireIntensity = (srcFireIntensity^0.5)*(FireIntensity^0.5)
   END

   //continue = (frontSize > 0) AND (FireIntensity > 0) AND (Time < endBurnTime) AND (Burnt < (MaxTimeSinceDisturbance - BaseTimestep + 1)) AND (actualSize < (MaxFireSize/HaPerCell))   // max size in cells. PJ07)
   continue = IF rSizeBasedFire
              THEN (remSize > 0) AND (Burnt < (MaxTimeSinceDisturbance - BaseTimestep + 1))
              ELSE (frontSize > 0) AND (FireIntensity > 0) AND (Time < endBurnTime) AND (actualSize < (FireMaxSize/HaPerCell))   // max size in cells. PJ07
              
   // Special case for termination: decrement fire front info
   IF !continue
      frontSize = frontSize - 1
   END

   // Only continue if there is still area to burn AND if the stand didn't just burn during this event
   TRANSITIONS = continue

   // Compute duration to burn cell
   TimeToBurnCell = 2^(5 * (1-FireIntensity))             
   FireClass = ROUND(5*FireIntensity)

   // Decide if this cell is burning, or if it is an unburned island within the fire boundary
   // This helps to create more realistic fires, i.e. those with more skips.
   isBurning = IF srcIsBurning THEN (UNIFORM(0,1) >= FireProbUnburned[0]) // prob of burning, given source was burning
               ELSE (UNIFORM(0,1) >= FireProbUnburned[1])  // prob of burning, given source was NOT burning

   // Apply damage...
   // Only for forested cells
   IF (Species > 0)  AND (isBurning) AND ((!ApplyFireFuelEffect) OR (FBPFuels > 0))
      actualSize = actualSize + 1
      remSize = remSize - 1

      // Record unsalvageable loss from a previous disturbance. Assume any unsalvaged yield is burned
      IF (SalvageableVolume > 0)
         VolumeUnsalvaged[LastDisturbance,Salvageable] = VolumeUnsalvaged[LastDisturbance,Salvageable] - SalvageableVolume
         VolumeUnsalvaged[rFire,Lost] = VolumeUnsalvaged[rFire,Lost] + SalvageableVolume
      END

      Yield = (VolPerHa/VolScale) * HaPerCell
      lost = 0.2 * Yield
      SalvageableVolume = ROUND(Yield - lost)

      // Record unsalvageable loss and increment the unsalvaged burned for this year
      VolumeUnsalvaged[rFire,Lost] = VolumeUnsalvaged[rFire,Lost] + lost
      VolumeUnsalvaged[rFire,Salvageable] = VolumeUnsalvaged[rFire,Salvageable] + SalvageableVolume
      AreaDisturbed[rFire,rForestDisturbed] = AreaDisturbed[rFire,rForestDisturbed] + HaPerCell
   END

   // Note: Age and Species reassignements in Succession.lse
   IF isBurning
      // Only stand replacing fire here
      Burnt = MaxTimeSinceDisturbance - yearInPeriod
      LastDisturbance = rFire
      VolPerHa = 0 // No more volume when burned --> but there remains the SalvageableVolume

       // Increment the yearly volume and areas Burnt
      VolumeBurnedByZone[ManagementZone] = VolumeBurnedByZone[ManagementZone] + Yield
      AreaBurnedByZone[ManagementZone] = AreaBurnedByZone[ManagementZone] + HaPerCell
      AreaBurnedByLandUnit[LandUnit] = AreaBurnedByLandUnit[LandUnit] + HaPerCell
      VolDisturbed[rFire] = VolDisturbed[rFire] + Yield
      AreaDisturbed[rFire,rTotalDisturbed] = AreaDisturbed[rFire,rTotalDisturbed] + HaPerCell
   END
ENDTR

SPREADTIME
   // See if fire duration has been exceeded
   IF (FireModelType EQ rDurationBasedFire) AND (Time > endBurnTime)
      frontSize = 0
   END

   // Spread according to length of time to burn cell
   SPREADTIME = IF (FireModelType EQ rDurationBasedFire) 
                THEN stepTime * TimeToBurnCell 
                ELSE 0 // size based fire

   // Remove cell from the front
   frontSize = MAX(0,frontSize - 1)
ENDST

SPREADLOCATION
   // Spread to the eight neighbours, provided they are unburnt
   REGION CENTRED(1, 1.5)
      DECISION (StudyArea > 0) AND (Burnt < (MaxTimeSinceDisturbance - (BaseTimestep + 1)))
ENDSL

// Manipulating NUMSPREADRECIPIENTS will just have the same effect as changing the SPREADPROB values.
// Here I set them equal to between 0.2 to 0.6 in 0.1 increments as a function of the 5 fire classes.  Square fires resulted from 
// having too high (i.e., 0.9) spread prob with high ISI and thus highest fireclass.  
SPREADPROB
   SPREADPROB = IF ApplyFireFuelEffect
                THEN IF (frontSize < 20) THEN 1 
                     ELSE CLASSIFY(SOURCE FireClass)
                            1:0.2
                            2:0.3
                            3:0.4
                            4:0.5
                            5:0.6
                          END
                ELSE IF (frontSize < 10) THEN 1 ELSE 0.25 //0.5

   // Increment the front for selected cells
   frontSize = frontSize + 1
   srcFireIntensity = SOURCE FireIntensity
   srcIsBurning = SOURCE isBurning
ENDSP

ENDCLUSTER
   // Fire information output file when fire opening is finished
   OUTPUT(fFireRate)
   DECISION actualSize > 0
      Run
      Year: FLOOR(Time)
      StartEcoRegion:initRegion
      StartFuel: initFuel
      FireISI: ISI
      TargetSize: targetSize * HaPerCell
      FinalSize: actualSize*HaPerCell
      TargetDuration: targetDuration/stepTime
      FinalDuration: (Time-startBurnTime)/stepTime
   END

   ENDCLUSTER = TRUE
ENDEC
