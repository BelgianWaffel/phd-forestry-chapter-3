// Combination of stats from fragstats and apack
// Note: A particular problem should decide on stats required
// and adapt a custom stats event, which may include some of the
// stats herein, and may include new or modified stats.
// Apack stats are denoted using lower case identifiers.
LSEVENT: IdentifyPatches

DEFINITIONS
   GLOBAL CONSTANT : HaPerCell, CellWidth, MaxPatchTypes, pi
   GLOBAL VARIABLE: BaseTimestep // Base Time step (in years)
   GLOBAL VARIABLE: NumPatchTypes, MinPatchType

   LAYER: StudyArea, SuccessionGroup, Species, StandAge, StandAge2, PctCohort2 // input layers from core model
   LAYER: PatchType, PatchId, CoreAreaId, EdgeInterior // produced by patch metric component
   GLOBAL CONSTANT: rEdge, rInterior
  
   GLOBAL VARIABLE: TotArea[] // Area of patches by tpe
   GLOBAL VARIABLE: NumPatches[] // Number of patches by type

   GLOBAL VARIABLE: TotalEdge[], TotalEdgeArea[]   // Edge Indices
   GLOBAL VARIABLE: TCA[], NumCA[]   // Core Area Indices
   GLOBAL VARIABLE: Eik[]   // Adjacency matrix
   GLOBAL VARIABLE: NumNeighbs[], NumSameNeighbs[]  // Contagion

   // Patch list
   GLOBAL CONSTANT: NumPatchStats, rId, rType, rArea, rCoreArea, rPerim, rCentroid, rMaxCCE, rNNDist
   GLOBAL LIST{NumPatchStats} VARIABLE: patchList[], coreAreaList[]
   LOCAL: patchVar[NumPatchStats]

   LOCAL: pId, coreId
   EVENT VARIABLE: isPatchEvent, currType
   CLUSTER VARIABLE: numActiveCells, currPatchSize, currPatchCoreSize,currPatchPerim
   CLUSTER VARIABLE: rowTotal, colTotal
ENDDEF

INITIALSTATE
   // Two types of instances: the first NumPatchType instances identify and computes first order stats for patches
   //  (a separate instance is used per type so that the list is ordered by type)
   // The second identifies  and computes first order stats for core areas
   INITIALSTATE = 1 + NumPatchTypes
   isPatchEvent = EventId <= NumPatchTypes
   currType = EventId + MinPatchType - 1   // This is ok for patches, but don'tuse for core areas
ENDIS

RETURNTIME
   RETURNTIME = IF Time EQ 0 THEN 0.12 ELSE BaseTimestep

   // Clear lists
   IF currType EQ MinPatchType
      OVER INDEX(0,MaxPatchTypes)
         REMOVE ALL(patchList[Index])
         REMOVE ALL(coreAreaList[Index])
       END
      pId = 0
      coreId = 0

       // clear output layers
      EdgeInterior = 0
      PatchId = 0
      CoreAreaId = 0

      // Clear old values: need to do for all arrays and global variables
      TotArea [=] 0
      NumPatches [=] 0
      NumCA [=] 0

      TotalEdge [=] 0
      TotalEdgeArea [=] 0
      TCA [=] 0
      NumCA [=] 0
      Eik [=] 0
      NumNeighbs [=] 0
      NumSameNeighbs [=] 0
   END


   // Compute patch layer
   OVER REGION WHOLE MAP 
      DECISION (StudyArea > 0) AND (SuccessionGroup > 0) AND (Species > 0)

      IF (PctCohort2 > 0)
         EffAge = IF (PctCohort2 > 50) THEN StandAge2 ELSE StandAge
      ELSE
         SppInv = Species
         EffAge = StandAge
      END

      PatchType = (EffAge > 15) + (EffAge > 40) + (EffAge > 80) + (EffAge > 120) + (EffAge > 160) + 1 // 5 categories
	
//       PatchType = (StandAge > 20) + (StandAge > 40) + (StandAge > 60) + (StandAge > 80) + (StandAge > 100) + (StandAge > 120) + (StandAge > 140) +
//      (StandAge > 160) + (StandAge > 180) + (StandAge > 200) + (StandAge > 220) + (StandAge > 240) + (StandAge > 260) + (StandAge > 280) + 1 
   END
ENDRT

PROBINIT
   PROBINIT = IF (isPatchEvent) THEN (PatchType EQ currType) AND (StudyArea > 0)
              ELSE (EdgeInterior EQ rInterior)
   numActiveCells = 0
   currPatchSize = 0
   currPatchCoreSize = 0
   currPatchPerim = 0
   rowTotal = 0
   colTotal = 0

   // For the patches ...
   IF (isPatchEvent)
      pId = pId + (PatchId EQ 0)
      TotArea[PatchType] = TotArea[PatchType] + 1
      NumPatches[PatchType] = NumPatches[PatchType] + (PatchId EQ 0)

   // For the core areas ...
   ELSE
      coreId = coreId + (CoreAreaId EQ 0)
      NumCA[PatchType] = NumCA[PatchType] + (CoreAreaId EQ 0)
   END
ENDPI


TRANSITIONS
   TRANSITIONS = IF isPatchEvent THEN (PatchId EQ 0) ELSE (CoreAreaId EQ 0)

   // For the patches ...
   IF isPatchEvent
      numSimilarNeighbours = 0
      numDifferentNeighbours = 0
      OVER REGION CENTRED(1, 1)
         DECISION (0 <= PatchType < (MinPatchType + NumPatchTypes)) AND(StudyArea > 0)
         similarNeighb = (PatchType EQ currType)
         numSimilarNeighbours = numSimilarNeighbours + similarNeighb
         numDifferentNeighbours = numDifferentNeighbours + (similarNeighb EQ FALSE)

         NumNeighbs[PatchType] = NumNeighbs[PatchType] + 1
         NumSameNeighbs[PatchType] = NumSameNeighbs[PatchType] + similarNeighb 

         Eik[currType, PatchType] = Eik[currType, PatchType] + (similarNeighb EQ FALSE)
      END

      currPatchPerim = currPatchPerim + 4 - numSimilarNeighbours
      TotalEdge[PatchType] = TotalEdge[PatchType] + numDifferentNeighbours

      // Add in the diagonal neighbours
      OVER REGION CENTRED(1.1, 1.5, EUCLIDEAN)
         DECISION (0 <= PatchType < (MinPatchType + NumPatchTypes))
         similarNeighb = (PatchType EQ currType)
         numSimilarNeighbours = numSimilarNeighbours + similarNeighb 
         numDifferentNeighbours = numDifferentNeighbours + (similarNeighb EQ FALSE)
      END

      EdgeInterior = IF (numDifferentNeighbours > 0) THEN rEdge ELSE rInterior

      TCA[PatchType] = TCA[PatchType] + (EdgeInterior EQ rInterior)
      TotalEdgeArea[PatchType] = TotalEdgeArea[PatchType] + (EdgeInterior EQ rEdge)
      PatchId = pId
   ELSE
      CoreAreaId = coreId
   END

   currPatchSize = currPatchSize + 1
   currPatchCoreSize = currPatchCoreSize + (EdgeInterior EQ rInterior)

   numActiveCells = numActiveCells + 1

   rowTotal = rowTotal + FLOOR(Location / NUMCOLS)
   colTotal = colTotal + (Location % NUMCOLS)
ENDTR

SPREADLOCATION
   REGION CENTRED(1, 1.5)
      DECISION IF isPatchEvent THEN (PatchId EQ 0) AND (PatchType EQ currType)AND (StudyArea > 0)
               ELSE (CoreAreaId EQ 0) AND (EdgeInterior EQ rInterior) //AND(PatchType EQ currType)
ENDSL

SPREADTIME
   SPREADTIME = -1

   // If numActiveCells becomes 0, then this patch is done
   numActiveCells = numActiveCells - 1

   IF (numActiveCells EQ 0)
      // Add the patch to the list
      patchVar[rArea] = currPatchSize
      patchVar[rCoreArea] = currPatchCoreSize
      patchVar[rPerim] = currPatchPerim
      patchVar[rCentroid] = FLOOR(rowTotal/currPatchSize) * NUMCOLS + FLOOR(colTotal/currPatchSize)
      patchVar[rMaxCCE] = 0
      patchVar[rNNDist] = -1

      IF isPatchEvent
         patchVar[rType] = currType
         patchVar[rId] = pId
         INSERT TAIL(patchList[currType], patchVar)
      ELSE
         patchVar[rType] = PatchType
         patchVar[rId] = coreId
         INSERT TAIL(coreAreaList[PatchType], patchVar)
      END
   END
ENDST

