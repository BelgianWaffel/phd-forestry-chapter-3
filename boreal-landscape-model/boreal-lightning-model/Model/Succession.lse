// Landscape event definition for succession in the Boreal landscape model
LSEVENT: Succession

DEFINITIONS
   /////////////////////////////////////////////////
   // INPUT STATE - constants and parameters
   /////////////////////////////////////////////////
   GLOBAL CONSTANT: HaPerCell, MaxStandAge, NumSppCodes, NumSuccGrps
   LAYER: StudyArea, LandUnit, SuccessionGroup, Ecoregion, FBPFuels
   LAYER: VolPerHa

   GLOBAL VARIABLE: BaseTimestep // Base Time step (in years)

   // Whether to apply species succession or leave Spp static
   GLOBAL VARIABLE: ApplySppSuccession

   // Probability of selecting trajector from a "like" neighbour (same age/species before disturbance).
   GLOBAL VARIABLE: pTrajContagion

   // Probability of an Spp (row: Spp x NumSuccGrps, col: 10 year age class (up to 120))
   GLOBAL CONSTANT: pTreeSpp[], NumSuccRows, pSymmetricIncrease[], SppContagion[]
   GLOBAL CONSTANT: NumAC, NumAgeClasses, ACSize, SppTranslate  // NumAC is for succession, NumAgeClasses is for reporting/tracking

   // Lookup a leading (col 0) or secondary (col 1) species given an Spp (row)
   GLOBAL CONSTANT: SppLookup[], rStandType, rFuelAge0, rFuelAge1, rFuelAge2, rHostType, rFuelPostSBW, rSecondary, rLead
   GLOBAL CONSTANT: SppCombine[]  

   GLOBAL VARIABLE: SeralTransitionYears
   GLOBAL CONSTANT: sBb, sPe, sPg, sE, sS, sMe, sC, sUnk

   /////////////////////////////////////////////////
   // INPUT STATE - INTERNAL (computed in initial state)
   /////////////////////////////////////////////////
   LOCAL: pTreeSppVector[NumSppCodes], pReceiveTransition[NumSuccGrps*NumAC,NumSppCodes], pMakeTransition[NumSuccGrps*NumAC,NumSppCodes], Q[NumSuccGrps*NumAC*NumSppCodes,NumSppCodes]
   LOCAL: Qtmp[NumSppCodes,NumSppCodes], pTmp[NumSppCodes]

   LOCAL: pTreeSppVector2[NumSppCodes], pReceiveTransition2[NumSuccGrps*NumAC,NumSppCodes], pMakeTransition2[NumSuccGrps*NumAC,NumSppCodes], Q2[NumSuccGrps*NumAC*NumSppCodes,NumSppCodes]
   LOCAL: Qtmp2[NumSppCodes,NumSppCodes], pTmp2[NumSppCodes]

   /////////////////////////////////////////////////
   // INPUT STATE - dynamic in other events
   /////////////////////////////////////////////////
   LAYER: LastDisturbance  // type of last disturbance
   GLOBAL CONSTANT: rSBW1, rSBW2, rSBW3, rFire 
   LAYER: Burnt, AttackedSB, SBWMortality, PctCohort2 
   GLOBAL CONSTANT: MaxTimeSinceDisturbance
   GLOBAL CONSTANT: postSBWNonHost, postSBWHost, pctHosts

   // GLOBAL CONSTANT: rAC

   /////////////////////////////////////////////////
   // FEEDBACK STATE
   /////////////////////////////////////////////////
   LOCAL: currMgmtZoneSchedId
   LAYER: StandAge,  Species,  NextTransAge,  NextTransYr,  NumTrans 
   LAYER: StandAge2, Species2, NextTransAge2, NextTransYr2, NumTrans2 
   LAYER: AU, PreDisturbanceAge, PreDisturbanceSpp, PreDisturbanceAge2, PreDisturbanceSpp2

   LIST{2} LAYER: TransTrajectory, TransTrajectory2
   LOCAL: singleTrans[2], singleTrans2[2]

   LAYER: SalvageableVolume
   GLOBAL VARIABLE: SalvageDecayTime, SalvageDecayDelay, VolumeUnsalvaged[]
   GLOBAL CONSTANT: Salvageable, Lost

   /////////////////////////////////////////////////
   // OUTPUT STATE
   /////////////////////////////////////////////////
   GLOBAL VARIABLE: ForestSize, SGSize[], LUSize[] 
   
   GLOBAL VARIABLE: SizeByClass[] 

   LAYER: StandType
   LOCAL: LikeNeighbLoc[4] // To store "like" neighbours

   GLOBAL VARIABLE: SpeciesByLU[], SpeciesLeadByLU[], StandTypeByLU[]  // by SppCode/SppLeadCode, LandUnit
   GLOBAL VARIABLE: SpeciesBySG[], SpeciesLeadBySG[]  // by SppCode/SppLeadCode, SuccessionGroup
   GLOBAL VARIABLE: NumSppTrans[], NumSppTrans2[] // by SppLeadCode, SppLeadCode

   //GLOBAL VARIABLE: HostSppByLU[] 

   OUTPUT VARIABLE: tmpFile = "pRelSppFile.txt"
   OUTPUT VARIABLE: tmp2File = "pSppFromTo.txt"

   // SBW reporting
   //!!?   OUTPUT VARIABLE: fSBWEvents = SBWEvents.txt

   GLOBAL VARIABLE: AreaDefoliated, SBWEffectLag, inOutbreak, SBWSchedIndex, SBWSched[], SBWDur[]

ENDDEF

INITIALSTATE

// ############################################################################################
   pTreeSppVector[0] = 0
   pTreeSppVector2[0] = 0

   OVER INDEX(1,NumSuccGrps-1)
      sg = Index

      OVER INDEX(1,NumSppCodes-1)
         DECISION (sg * NumSppCodes + Index) < NumSuccRows
         sppId = Index
         i = sg * NumSppCodes + sppId

         // Use translation if specified
         newSpp = sppId
         IF (pTreeSpp[i,SppTranslate] > 0)
            i = pTreeSpp[i,SppTranslate]
            newSpp= i % (sg * NumSppCodes)
         END

         id = sg * NumAC
         pReceiveTransition[id,sppId] = pTreeSpp[i, 0]
         pMakeTransition[id,sppId] = 0

         pReceiveTransition2[id,sppId] = pTreeSpp[i, 0]
         pMakeTransition2[id,sppId] = 0

         OVER INDEX(1, NumAC-1)
            pDelta = pTreeSpp[i,Index] - pTreeSpp[i,Index-1]
            pOld = pTreeSpp[i,Index-1]

            // If this is a stable or increasing period
            IF (pDelta >= 0)
               pIn = pSymmetricIncrease[i,Index] + pDelta
               pOut = pSymmetricIncrease[i,Index]
            ELSE
               pIn = pSymmetricIncrease[i,Index]
               pOut = pSymmetricIncrease[i,Index] - pDelta
            END

            // If translated, no in-transitions
            IF sppId NEQ newSpp
               pIn = 0
            END

            IF (pOut <= 0) AND (pTreeSpp[i, Index] EQ 0) AND (pTreeSpp[i, Index-1] > 0)
               pMin = 0.02  // Minimum resolution is 0.02% (0.0002) 
               pOut = pMin
               pOld = pMin
            END

            id = sg * NumAC + Index

            pMakeTransition[id,sppId] = pOut/pOld
            pMakeTransition2[id,sppId] = pOut/pOld

            pReceiveTransition[id,sppId] = pIn/100
            pReceiveTransition2[id,sppId] = pIn/100

         END

         k = 0

         OVER INDEX(0,NumAC-1)
            k = k + pTreeSpp[i,Index] + pReceiveTransition[sg * NumAC + Index,sppId] + pMakeTransition[sg * NumAC + Index,sppId]
         END

         OUTPUT(tmpFile)  
            DECISION (k > 0)
            SuccGrp: $sg {SuccessionGroup}
            Spp: $sppId {Species}

            ac0:  pTreeSpp[i,0]
            ac20: pTreeSpp[i,1]
            ac40: pTreeSpp[i,2]
            ac60: pTreeSpp[i,3]
            ac80: pTreeSpp[i,4]
            ac100:pTreeSpp[i,5]

            pGetTrans_ac0:  pReceiveTransition[sg * NumAC,sppId]
            pGetTrans_ac20: pReceiveTransition[sg * NumAC + 1,sppId]
            pGetTrans_ac40: pReceiveTransition[sg * NumAC + 2,sppId]
            pGetTrans_ac60: pReceiveTransition[sg * NumAC + 3,sppId]
            pGetTrans_ac80: pReceiveTransition[sg * NumAC + 4,sppId]
            pGetTrans_ac100:pReceiveTransition[sg * NumAC + 5,sppId]

            pMakeTrans_ac0:  pMakeTransition[sg * NumAC,sppId]
            pMakeTrans_ac20: pMakeTransition[sg * NumAC + 1,sppId]
            pMakeTrans_ac40: pMakeTransition[sg * NumAC + 2,sppId]
            pMakeTrans_ac60: pMakeTransition[sg * NumAC + 3,sppId]
            pMakeTrans_ac80: pMakeTransition[sg * NumAC + 4,sppId]
            pMakeTrans_ac100:pMakeTransition[sg * NumAC + 5,sppId]
         END
      END
   END

// ################################################################################

   // Set up temporal contagion 
   OVER INDEX(0,NumSuccGrps-1)
      sg = Index
      OVER INDEX(0, NumAC-1)
         ac = Index
         id = sg * NumAC + Index
         // Q[id*NumSppCodes] = CONTAG(pReceiveTransition[id], C)
         OVER INDEX(0, NumSppCodes-1)
            pTmp[Index] = pReceiveTransition[id,Index]
            pTmp2[Index] = pReceiveTransition2[id,Index]

         END

         Qtmp [=] CONTAG(pTmp, SppContagion)
         Qtmp2 [=] CONTAG(pTmp2, SppContagion)

         OVER INDEX(0, NumSppCodes-1)
            fromSpp = Index
            OVER INDEX(0, NumSppCodes-1)
               toSpp = Index
               Q[id*NumSppCodes+fromSpp, toSpp] = Qtmp[fromSpp, toSpp]
               Q2[id*NumSppCodes+fromSpp, toSpp] = Qtmp2[fromSpp, toSpp]

                i = sg * NumSppCodes + fromSpp
                
                OUTPUT(tmp2File)
                   DECISION (ac > 0) AND (SppLookup[fromSpp,0] > 0) AND (i < NumSuccRows) AND (pTreeSpp[i,ac] > 0) AND (Qtmp[fromSpp, toSpp] > 0)
                      SuccGrp: $sg {SuccessionGroup}
                      AC: ac
                      FromSpp: $fromSpp{Species}
                      ToSpp: $toSpp{Species}
                      pTrans: Qtmp[fromSpp, toSpp]
                      contag: SppContagion[fromSpp, toSpp]
                      pctChange: 100*(Qtmp[fromSpp, toSpp] - pReceiveTransition[id,toSpp])/pReceiveTransition[id,toSpp]
                END
            END
         END
      END
   END

   // Set up tracking variables.
   // Only need to consider forested cells.
   OVER REGION WHOLE MAP
      DECISION (StudyArea > 0) AND (SuccessionGroup > 0) AND (Species > 0)
         ForestSize = ForestSize + 1
         SGSize[SuccessionGroup] = SGSize[SuccessionGroup] + 1

         ageClass = MIN(FLOOR(StandAge/ACSize), NumAgeClasses-1)
         SizeByClass[ageClass] = SizeByClass[ageClass] + 1

         // Set up initial state for stand type map
         StandType = SppLookup[Species, rStandType]
         lead = SppLookup[Species, 0]
         SpeciesLeadBySG[lead, SuccessionGroup] = SpeciesLeadBySG[lead,SuccessionGroup] + 1
         SpeciesBySG[Species, SuccessionGroup] = SpeciesBySG[Species,SuccessionGroup] + 1

         // Track species composition
         IF (LandUnit > 0)
            LUSize[LandUnit] = LUSize[LandUnit] + 1
            LUSize[0] = LUSize[0] + 1
            SpeciesLeadByLU[lead, LandUnit] = SpeciesLeadByLU[lead,LandUnit] + 1
            SpeciesByLU[Species, LandUnit] = SpeciesByLU[Species,LandUnit] + 1
            StandTypeByLU[StandType, LandUnit] = StandTypeByLU[StandType,LandUnit] + 1
         END

         // FBP Fuel Classification - simple - no SBW damage
         // #################################################################################################
            FBPFuels = IF StandAge <= 5 THEN SppLookup[Species, rFuelAge0]
                       ELSE IF 5 < StandAge <= 20 THEN SppLookup[Species, rFuelAge1]
                       ELSE SppLookup[Species, rFuelAge2]

   END

   // This lets us have a legend for species 2. 
   Species2 = 0 // Species2 is read in same as 'Species' and is now set to zero.

   SGSize[0] = ForestSize

   INITIALSTATE = 1
ENDIS

RETURNTIME
/* //?
   // #####  SBW REPORTING   
   // ##########################################################################################

   OUTPUT(fSBWEvents )
      Run
      Year: FLOOR(Time)
      OutbreakNumber: SBWSchedIndex  //outbreakNum
      startYear: SBWSched[SBWSchedIndex]
      endYear: SBWSched[SBWSchedIndex] + SBWDur[SBWSchedIndex]
      Epidemic :inOutbreak
      CumulAreaHa:(AreaDefoliated * HaPerCell)
   END

   AreaDefoliated  = IF ((AreaDefoliated > 0) AND (Time > SBWSched[SBWSchedIndex-1])) THEN 0 ELSE AreaDefoliated
*/

   // ##########################################################################################

   RETURNTIME = IF Time EQ 0 THEN 0.1 ELSE BaseTimestep

   // Clear tracking arrays
   SizeByClass [=] 0


   IF ApplySppSuccession
      SpeciesLeadBySG [=] 0  // By SppLeadCode, SuccGrp
      SpeciesLeadByLU [=] 0  // By SppLeadCode, LU
      SpeciesBySG [=] 0  // By SppCode, SuccGrp
      SpeciesByLU [=] 0  // By SppCode, LU

   END

   // Update time since disturbance information
   // Has to be here b/c SBW doesn't always happen (i.e., req.'s outbreak)
   OVER REGION WHOLE MAP
      DECISION AttackedSB > 0
        AttackedSB = MAX(AttackedSB - BaseTimestep, 0)
   END

   // Clear Species in first step to "force" trajectories to be built
   IF FLOOR(Time) <= 0
      PreDisturbanceSpp = Species
      Species = 0
   END

ENDRT

// Only process forested cells
EVENTLOCATION
   STATIC REGION WHOLE MAP
      DECISION (StudyArea > 0) AND (Species > 0) AND (SuccessionGroup > 0)
ENDEL

// Probability of a transition
PROBINIT

   prevStandAge = StandAge

   //## CRITICAL FLAG TO TELL MODEL THAT A DISTURBANCE OCCURRED
   timeSinceDisturbance = MaxTimeSinceDisturbance - MAX(Burnt, AttackedSB)
   Logged = MAX(Logged-BaseTimestep, 0)
   
   // Increment the stand age in years for each forested cell (except in first pass and for recent disturbances)
   IF (FLOOR(Time) > 0) AND (timeSinceDisturbance >= BaseTimestep)
      StandAge = MIN(StandAge + BaseTimestep, MaxStandAge)
      StandAge2 = IF (PctCohort2 > 0) THEN MIN(StandAge2 + BaseTimestep, MaxStandAge) ELSE 0
   END

   // Re-compute tracking variables
   // Get age for some variables before it is incremented so we don't lose age '0' stands

   ageClass = MIN(FLOOR(StandAge /ACSize), NumAgeClasses-1)
   SizeByClass[ageClass] = SizeByClass[ageClass] + 1

   IF (PctCohort2 > 0)
      l1 = SppLookup[Species,  0]
      l2 = SppLookup[Species2, 0]
      SppInv = IF (PctCohort2 > 50) THEN SppCombine[l2,l1] 
               ELSE SppCombine[l1,l2]
      EffAge = IF (PctCohort2 > 50) THEN StandAge2 
               ELSE StandAge
   ELSE
      SppInv = Species
      EffAge = StandAge
   END

   // FBP Fuel Classification
   // ###################################################################
   IF (SBWMortality > 0) // right after defoliation 
      IF (LastDisturbance >= rSBW1) AND (timeSinceDisturbance <= SBWEffectLag)  // if we have been recently defoliated
         pctDeadFir = 0 // Calculate what percentage of dead fir/spruce is in the stand

         // Cohort 1 components
         // LEAD
         IF (SppLookup[Species, rLead] EQ sS) OR (SppLookup[Species, rLead] EQ sE)// lead
            pctDeadFir = pctDeadFir + (66 * (1-(PctCohort2 /100)))
         END
         // SECONDARY
         IF (SppLookup[Species, rSecondary] EQ sS) OR (SppLookup[Species, rLead] EQ sE) // secondary
            pctDeadFir = pctDeadFir + (33 * (1-(PctCohort2 /100)))
         END

         // Cohort 2 components
         IF (PctCohort2 >0) AND (LastDisturbance >= rSBW2)
            IF (SppLookup[Species2, rLead] EQ sS) OR (SppLookup[Species, rLead] EQ sE)// lead
               pctDeadFir = pctDeadFir + (66 * (PctCohort2 /100))
            END

            IF (SppLookup[Species2, rSecondary] EQ sS) OR (SppLookup[Species, rLead] EQ sE)// secondary
               pctDeadFir = pctDeadFir + (33 * (PctCohort2 /100))
            END
         END

         // Assign fuel classes based on amount of dead fir.
        FBPFuels = 11 - (pctDeadFir > 34) - (pctDeadFir > 75) 
      END 

   ELSE // Regular lookup 
      IF (FBPFuels >= 9) AND (timeSinceDisturbance <= SBWEffectLag) 
         FBPFuels =FBPFuels
      ELSE IF (FBPFuels EQ 9) AND (LastDisturbance >= rSBW1) AND ((SBWEffectLag+5) > timeSinceDisturbance > SBWEffectLag) 
         FBPFuels = 11 // M3-25 
      ELSE
         FBPFuels = IF (StandAge <=5) THEN SppLookup[SppInv, rFuelAge0]
                    ELSE IF (5 < StandAge <= 20) THEN SppLookup[SppInv, rFuelAge1]
                    ELSE SppLookup[SppInv, rFuelAge2]
      END 
   END 

   // Handle salvage decay
   // ###################################################################
   IF (SalvageableVolume > 0)
      TimeSinceDecayStart = StandAge - SalvageDecayDelay
      IF TimeSinceDecayStart > 0
         VolumeLost = ROUND(CLAMP(UNIFORM TEMPORAL PDF(TimeSinceDecayStart, 0, SalvageDecayTime),0,1) * SalvageableVolume)
         SalvageableVolume = SalvageableVolume - VolumeLost
         VolumeUnsalvaged[LastDisturbance, Lost] = VolumeUnsalvaged[LastDisturbance, Lost] + VolumeLost
         VolumeUnsalvaged[LastDisturbance, Salvageable] = VolumeUnsalvaged[LastDisturbance, Salvageable] - VolumeLost
      END
   END

   // ###################################################################
   // STEP #1 --> Apply species succession if this flag is set        ###
   // ###################################################################

   IF ApplySppSuccession
   // In first period, or after reset, recompute trajectory
   // Other years: check if a transition is to be made

      // ### First year or after reset.....
      // ###################################################################

      IF (FLOOR(Time) <= 0) OR (timeSinceDisturbance < BaseTimestep) OR (SBWMortality >= 1)
      // IF (FLOOR(Time) <= 0) OR (prevStandAge < BaseTimestep) OR (SBWMortality >= 1)
        
         yearInPeriod = MIN(FLOOR(UNIFORM(0, BaseTimestep)), BaseTimestep-1)

         IF (SBWMortality >= 1)   
             // Track Cohort1 age and species before disturbance 
            PreDisturbanceAge = StandAge
            PreDisturbanceSpp = Species                  
            // Also track Cohort2 age and species before disturbance.  Will EQ 0 IF (PctCohort2 EQ 0)
            PreDisturbanceAge2 = IF (PctCohort2 > 0) THEN StandAge2 ELSE 0
            PreDisturbanceSpp2 = IF (PctCohort2 > 0) THEN Species2  ELSE 0
         END

         //  ### Damage for when all host species are killed - (SBWMortality EQ 1)
         //  #################################################
         IF (SBWMortality EQ 1) 

            // Remove old analysis unit -  here = species
            AU = MAX((AU - SppLookup[Species,3]) ,3)
 
            IF (PctCohort2 <= 0) // Single cohort 

               // ###################################################################################################
               // This section simply asks if the disturbance event was SBW and then assigns the new species to the 
               // site assuming that defoliation of hosts results in a return of hosts.  This is the first species 
               // that then feeds into the succession transition calculation further down.  Here, we also check if 
               // the whole cell was host, or whether only one of the 2 recorded species was.  If only one part of 
               // the cell was host, we assign a new 'cohort' to represent reinitiation of that portion of the cell.  
               // I.e., second cohort that has its own successional tracking inventory sees the lead of each cohort.
               // ###################################################################################################

               
               // UNIFORM SINGLE COHORT --> If 100% host, then create a new single cohort stand
               IF SppLookup[Species, postSBWNonHost] EQ 0 // no non-hosts

                  Species = SppLookup[Species,postSBWHost] // assign a full new species
                  StandAge = yearInPeriod 
                  VolPerHa= 0
              
               // MIXED SINGLE COHORT --> create two cohorts
               ELSE
                  currSpp=Species

                  PctCohort2 = SppLookup[currSpp, pctHosts]
                  Species = SppLookup[currSpp,postSBWNonHost]
                  Species2 = SppLookup[currSpp,postSBWHost] 

                  StandAge2 = yearInPeriod 

                  pctLost = ((SppLookup[Species, pctHosts])/100)
                  VolPerHa = (1 - pctLost) * VolPerHa  // loss of host volume here.  could do salvage. not yet
               END

               // Reassign AU based on newly assigned species
               // AU = MIN((AU + SppLookup[Species,3]), MaxAU) 

            // DOUBLE COHORT
            ELSE IF PctCohort2 > 0 

               // Reassign species   
               // ##############################################################################################
               // ## [1] ######################################################################################
 
               // If 100% host in both cohorts, then create a new single cohort stand
               IF (SppLookup[Species,postSBWNonHost] EQ 0) AND (SppLookup[Species2,postSBWNonHost] EQ 0) // no non-hosts

                  // If cohort2 is larger, use it, otherwise use cohort1
                  Species = IF (PctCohort2 > 50) THEN SppLookup[Species2,postSBWHost]
                            ELSE SppLookup[Species,postSBWHost]
                  StandAge  = yearInPeriod
                  VolPerHa = 0 // loss of host volume here.  could do salvage. not yet
                  //Shrubs = IF (PreDisturbanceAge < 30) THEN 1 ELSE 0

                  // Erase second cohort
                  PctCohort2 = 0 
                  Species2   = 0
                  StandAge2 = 0
                     
               // ## [2] ######################################################################################
               
               // If cohort1 is 100% host and cohort 2 is mixed, then create a new 2-cohort stand
               ELSE IF (SppLookup[Species,postSBWNonHost] EQ 0)
                    
                  currPct2host = SppLookup[Species2, pctHosts] 
                  currSpp = Species

                  Species = SppLookup[Species2,postSBWNonHost] // take non-host remainder and make cohort1
                  StandAge = StandAge2
                  StandAge2 = yearInPeriod 
                  Species2 = IF (currPct2host <= 0) THEN SppLookup[currSpp,postSBWHost] // assign a full new species
                             ELSE IF (PctCohort2 * (currPct2host/100)) > (100-PctCohort2) THEN SppLookup[Species2,postSBWHost]
                             ELSE SppLookup[currSpp,postSBWHost]

                  // Percent that is cohort 2 is percent cohort 1 (i.e. flip) plus the % of cohort2 that is host.
                  PctCohort2 = (100 - PctCohort2) + ((PctCohort2/100)*currPct2host)

                  // Because the amount of the cell being put into PctCohort2 represents the proportion of the cell that was killed, 
                  // we can use it as a handy substitute to determine what percentage of volume is left...i.e., (1-PctCohort2/100)

                  VolPerHa = (1-(PctCohort2/100))*VolPerHa // loss of host volume here.  could do salvage. not yet//!!!%%^&*
                     
               // ## [3] ######################################################################################

               // If cohort2 is 100% host and cohort 1 is mixed, then create a new 2-cohort stand
               ELSE IF (SppLookup[Species2,postSBWNonHost] EQ 0)

                  currPct1host = SppLookup[Species, pctHosts]
                  currSpp = Species 

                  Species = SppLookup[Species,postSBWNonHost]
                  Species2 = IF (currPct1host <= 0) THEN SppLookup[Species2,postSBWHost] // assign a full new species
                             ELSE IF (PctCohort2 > ((100-PctCohort2)*(currPct1host/100))) THEN SppLookup[Species2,postSBWHost]
                             ELSE SppLookup[currSpp,postSBWHost]

                  StandAge2 = yearInPeriod 

                  // percent that is cohort 2 is percent cohort 2 plus the % of cohort1 that is host
                  PctCohort2 = PctCohort2 + ((1-(PctCohort2/100))*currPct1host)

                  VolPerHa = (1-(PctCohort2/100))*VolPerHa // loss of host volume here.  could do salvage. not yet

               // ## [4] ####################################################################################

               //Both cohorts have some non-hosts -> create two cohorts
               ELSE
                  currPct1host = SppLookup[Species, pctHosts]
                  currPct2host = SppLookup[Species2, pctHosts]
                  nonHostSpp1 = SppLookup[SppLookup[Species,postSBWNonHost], 0] // first lookup "single species" then take the lead (which will be a codes like sBb or such)
                  nonHostSpp2 = SppLookup[SppLookup[Species2,postSBWNonHost], 0]
                  currSpp = Species
   
                  IF (PctCohort2 * (1-(currPct2host/100))) > ((100-PctCohort2)*(1-(currPct1host/100))) // then cohort 2 becomes the lead
                     Species = SppCombine[nonHostSpp2,nonHostSpp1]
                     StandAge = StandAge2
                  ELSE // cohort 1 becomes the lead
                     Species = SppCombine[nonHostSpp1,nonHostSpp2]
                  END

                  Species2 = IF (currPct1host <= 0) THEN SppLookup[Species2,postSBWHost]
                             ELSE IF (currPct2host <= 0) THEN SppLookup[currSpp,postSBWHost]
                             ELSE IF (PctCohort2 * (currPct2host/100)) > ((100-PctCohort2)*(currPct1host/100)) THEN SppLookup[Species2,postSBWHost]
                             ELSE SppLookup[currSpp,postSBWHost]

                  StandAge2 = yearInPeriod
                  // percent that cohort2 is % cohort1 hosts + % cohort2 hosts
                  PctCohort2 = ((1-(PctCohort2/100))*currPct1host) + ((PctCohort2/100)*currPct2host)

                  VolPerHa = (1-(PctCohort2/100))*VolPerHa // loss of host volume here.  could do salvage. not yet

               END
                  
               // Test for small cohorts
               IF (PctCohort2 <= 10) // too small, erase
                  PctCohort2 = 0
                  Species2 = 0
                  StandAge2 = 0
               ELSE IF (PctCohort2 >= 90) // cohort 1 is too small, flip and erase
                  PctCohort2 = 0
                  Species = Species2
                  StandAge = StandAge2
                  Species2 = 0
                  StandAge2 = 0
               END

            END

            // For all conditions where SBWMortality EQ 1  
            
            // # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
            // SPATIAL SUCCESSION POST-SBW --> assign "neighbour-based" new trajectory for cohort1 and cohort2 
            // #########################################################################################################

            usedNeighbourTraj = FALSE

            // Randomly choose if this cell uses a neighbour or selects an independent trajectory for C1 and C2
            IF (pTrajContagion > 0) AND (UNIFORM(0,1) <= pTrajContagion) 
               nLikeNeighbours = 0
               OVER REGION CENTRED(1,1)  // Rook neighbours
               DECISION ((Species > 0) AND (LastDisturbance >= rSBW1))
                  IF (PreDisturbanceSpp EQ (SOURCE PreDisturbanceSpp))
                     LikeNeighbLoc[nLikeNeighbours] = Location
                     nLikeNeighbours = nLikeNeighbours + 1
                  END    
               END
                 
               IF nLikeNeighbours > 0
                  // Pick one  
                  neighb = MIN(FLOOR(UNIFORM(0,nLikeNeighbours)), nLikeNeighbours-1)
                  AT LOCATION(LikeNeighbLoc[neighb])
                     usedNeighbourTraj = TRUE
                     SOURCE AU = AU
                     SOURCE Species = Species
                     REMOVE ALL(SOURCE TransTrajectory)
                     
                     SOURCE NumTrans = 0
                     p = HEAD(TransTrajectory)
                     WHILE(p)
                        singleTrans [=] GET(TransTrajectory, p)
                        p = NEXT(TransTrajectory,p)
                        // Add a new transition
                        INSERT TAIL(SOURCE TransTrajectory, singleTrans)
                        SOURCE NumTrans = SOURCE NumTrans + 1
                     END

                     // Cohort 2 as well...if it exists
                     IF ((PctCohort2 >0) AND (PreDisturbanceSpp2 EQ SOURCE PreDisturbanceSpp2))
                        SOURCE Species2 = Species2
                        REMOVE ALL(SOURCE TransTrajectory2)
                        SOURCE NumTrans2 = 0
                        p = HEAD(TransTrajectory2)
                        WHILE(p)
                           singleTrans2 [=] GET(TransTrajectory2, p)
                           p = NEXT(TransTrajectory2,p)
                           // Add a new transition
                           INSERT TAIL(SOURCE TransTrajectory2, singleTrans2)
                           SOURCE NumTrans2 = MIN(SOURCE NumTrans2 + 1 ,6)
                        END
                     END
                  END
               END
            END

            IF !usedNeighbourTraj  // Clear previous trajectories if we didn't use contagious succession
               REMOVE ALL(TransTrajectory)
               REMOVE ALL(TransTrajectory2)
            END

         //  Damage for when there is mortality of only older (first) cohort, not both.all host species are killed 
         //  ###########################################################################################################
         ELSE IF (SBWMortality EQ 2)
            // Remove old inventory based analysis unit
            AU = MAX((AU - CLAMP(SppLookup[Species,3],0,10)) ,3)

            // ## [1] ######################################################################################
            // If cohort1 is 100% host, then create a new 2-cohort stand
            IF (SppLookup[Species,postSBWNonHost] EQ 0)

               currPct2host = SppLookup[Species2, pctHosts]  // this value will always = 100 for cohort1
               currSpp = Species
               Species = Species2 // flip cohorts (cohort2 becomes cohort1)
               StandAge = StandAge2
               
               // If the amount of host in cohort2 is larger than the size of the cohort destroyed (cohort1) then
               // the cohort2 host species should determine the new cohort's identify (consider larger seed source)
               Species2 = IF (currPct2host <= 0) THEN SppLookup[currSpp,postSBWHost] // assign a full new species
                          ELSE IF (PctCohort2 * (currPct2host/100)) > (100-PctCohort2) THEN SppLookup[Species2,postSBWHost]
                          ELSE SppLookup[currSpp,postSBWHost]

               // percent that is cohort 2 is percent cohort 1 (i.e., flip)
               PctCohort2 = (100 - PctCohort2)
               VolPerHa = (1-(PctCohort2/100)) * VolPerHa // loss of host volume here. Could do salvage - not yet

            // ## [2] ######################################################################################
            // Both cohorts have some non-hosts -> create two cohorts  //!! should consider which species component is "smallest" (which one is "lost")
            ELSE
            
               currPct1host = SppLookup[Species, pctHosts]
               currPct2host = SppLookup[Species2, pctHosts]
               nonHostSpp1 = SppLookup[SppLookup[Species,postSBWNonHost], 0] // first lookup "single species" then take the lead (which will be a code like sBb or such)
               lead2 = SppLookup[Species2, 0]
               currSpp = Species

               //IF (PctCohort2 * (1-currPct2host/100)) > ((100-PctCohort2)*(1-currPct1host/100)) // then cohort 2 becomes the lead
               IF (PctCohort2) > ((100-PctCohort2)*(1-currPct1host/100)) // then cohort 2 becomes the lead
                  Species = SppCombine[lead2,nonHostSpp1]
                  StandAge = StandAge2
               ELSE // cohort 1 becomes the lead
                  Species = SppCombine[nonHostSpp1,lead2]
               END

               Species2 = IF currPct2host <= 0 THEN SppLookup[currSpp,postSBWHost]
               // !!! Consider combining influence of hosts from the two cohorts as above
                          ELSE IF (PctCohort2 * currPct2host/100) > ((100-PctCohort2)*currPct1host/100) THEN SppLookup[Species2,postSBWHost]
                          ELSE SppLookup[currSpp,postSBWHost]

               // percent that cohort2 is % cohort1 hosts
               PctCohort2 = (1-PctCohort2/100)* currPct1host
               VolPerHa = (1-(PctCohort2/100) )* VolPerHa // loss of host volume here. SALVAGE!

            END

            // AU = MIN((AU + CLAMP(SppLookup[Species,3],0,10)), MaxAU) 

            // For all conditions where SBWMortality was = 2  
            // ############################################################################################
            // SPATIAL SUCCESSION POST-SBW --> assign "neighbour-based" new trajectory for only cohort2 
            // ############################################################################################

            usedNeighbourTraj = FALSE
  
            // Randomly choose if this cell uses a neighbour or selects an independent trajectory
            IF ((pTrajContagion > 0) AND (UNIFORM(0,1) <= pTrajContagion)  AND (PctCohort2 > 0))
               nLikeNeighbours = 0
               OVER REGION CENTRED(1,1)
               DECISION (Species > 0) AND (LastDisturbance EQ rSBW2) // has to have a species identity and second cohort
                     IF (PreDisturbanceSpp EQ SOURCE PreDisturbanceSpp) 
                     LikeNeighbLoc[nLikeNeighbours] = Location
                     nLikeNeighbours = nLikeNeighbours + 1
                  END
               END
                 
               IF nLikeNeighbours > 0
                  // Pick one
                  neighb = MIN(FLOOR(UNIFORM(0,nLikeNeighbours)), nLikeNeighbours-1)
                  AT LOCATION(LikeNeighbLoc[neighb])
                     usedNeighbourTraj = TRUE
                     SOURCE AU = AU
                     SOURCE Species = Species
                     // Clear previous trajectory
                     REMOVE ALL(SOURCE TransTrajectory)
                     
                     SOURCE NumTrans = 0
                     p = HEAD(TransTrajectory)
                     WHILE(p)
                        singleTrans2 [=] GET(TransTrajectory, p)
                        p = NEXT(TransTrajectory,p)
                        // Add a new transition
                        INSERT TAIL(SOURCE TransTrajectory, singleTrans)
                        SOURCE NumTrans = MIN(SOURCE NumTrans + 1 ,6)
                     END

                     // Cohort 2 as well...if it exists
                     IF ((PctCohort2 >0) AND (PreDisturbanceSpp2 EQ SOURCE PreDisturbanceSpp2))
                        SOURCE Species2 = Species2
                        REMOVE ALL(SOURCE TransTrajectory2)
                        SOURCE NumTrans2 = 0
                        p = HEAD(TransTrajectory2)
                        WHILE(p)
                           singleTrans2 [=] GET(TransTrajectory2, p)
                           p = NEXT(TransTrajectory2,p)
                           // Add a new transition
                           INSERT TAIL(SOURCE TransTrajectory2, singleTrans2)
                           SOURCE NumTrans2 = MIN(SOURCE NumTrans2 + 1 ,6)
                        END
                     END
                  END
               END
            END

            IF !usedNeighbourTraj  // Clear previous cohort 1 trajectories
               REMOVE ALL(TransTrajectory)
               REMOVE ALL(TransTrajectory2)
            END
             
         //  Damage for when there is mortality of only younger (second) cohort. C1 may have had a vol. reduction
         //  ##############################################################################################################
         ELSE IF (SBWMortality EQ 3) // only 2nd cohort affected.
// no effect on AU
            IF (SppLookup[Species2,postSBWNonHost] EQ 0) // If second cohort is 100% host, lead spp. remains the same
               currSpp2 = Species2 
               Species2 = SppLookup[currSpp2,postSBWHost]
               StandAge2 = yearInPeriod 
               VolPerHa = (1-(PctCohort2/100))*VolPerHa // loss of host volume here.
            ELSE  // If second cohort is mixed, non-host takes lead.  the end.
               currPct2host = SppLookup[Species2, pctHosts] 
               currSpp2 = Species2
               Species2 = SppLookup[currSpp2,postSBWNonHost]
                // ###### Volume loss
               pctVolLost = ((currPct2host/100) * (PctCohort2/100)) // PJ!!
               VolPerHa = (1-pctVolLost) * VolPerHa // loss of host volume 
            END

            // For all conditions where SBWMortality was = 3  
            // ############################################################################################
            // SPATIAL SUCCESSION POST-SBW --> assign "neighbour-based" new trajectory for only cohort2 
            // ############################################################################################
   
            usedNeighbourTraj = FALSE
  
            // Randomly choose if this cell uses a neighbour or selects an independent trajectory
            IF ((pTrajContagion > 0) AND (UNIFORM(0,1) <= pTrajContagion)  AND (PctCohort2 > 0))
               nLikeNeighbours = 0
               OVER REGION CENTRED(1,1)
               DECISION (Species > 0) AND (PctCohort2 > 0) AND (LastDisturbance EQ rSBW3) // has to have a species identity and second cohort
                     IF (PreDisturbanceSpp2 EQ SOURCE PreDisturbanceSpp2) 
                     LikeNeighbLoc[nLikeNeighbours] = Location
                     nLikeNeighbours = nLikeNeighbours + 1
                  END
               END
                 
               IF nLikeNeighbours > 0
                  // Pick one
                  neighb = MIN(FLOOR(UNIFORM(0,nLikeNeighbours)), nLikeNeighbours-1)
                  AT LOCATION(LikeNeighbLoc[neighb])
                     usedNeighbourTraj = TRUE
                     SOURCE Species2 = Species2
                     // Clear previous trajectory
                     REMOVE ALL(SOURCE TransTrajectory2)
                     
                     SOURCE NumTrans2 = 0
                     p = HEAD(TransTrajectory2)
                     WHILE(p)
                        singleTrans2 [=] GET(TransTrajectory2, p)
                        p = NEXT(TransTrajectory2,p)
                        // Add a new transition
                        INSERT TAIL(SOURCE TransTrajectory2, singleTrans2)
                        SOURCE NumTrans2 = MIN(SOURCE NumTrans2 + 1 ,6)
                     END
                  END
               END
            END

            IF !usedNeighbourTraj  // Clear previous cohort 2 trajectories
               REMOVE ALL(TransTrajectory2)
            END
         // ############################################################################################

         ELSE // Time EQ 0 OR Mortality from logging or fire

            usedNeighbourTraj = FALSE
            baseIndex = SuccessionGroup * NumAC

            IF (FLOOR(Time) > 0) AND (timeSinceDisturbance < BaseTimestep)  // If Disturbed.
               IF (PctCohort2 > 0)
                   l1 = SppLookup[Species ,  0]
                   l2 = SppLookup[Species2, 0]

                   SppInv = IF (PctCohort2 > 50) THEN SppCombine[l2,l1] 
                            ELSE SppCombine[l1,l2]
               ELSE
                  SppInv = Species 
               END

               PreDisturbanceAge = StandAge
               PreDisturbanceSpp = SppInv

               // Single cohort now - only stand replacing fire and logging
               Species = 0  // clear species  //#***
               Species2 = 0                   //#*** 
               StandAge = yearInPeriod
               StandAge2 = 0
               PctCohort2 = 0
                  
               // Spatial Succession for post fire or logging  
               // #############################################

               // # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
               // Start spatially contagious succession
               // # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

               // Randomly choose if this cell uses a neighbour or selects an independent trajectory
               IF (pTrajContagion > 0) AND (UNIFORM(0,1) <= pTrajContagion) 
                  nLikeNeighbours = 0

                  OVER REGION CENTRED(1,1)
                  DECISION (Species > 0) AND ((MaxTimeSinceDisturbance - MAX(Logged,Burnt)) < BaseTimestep)
                     // Fire/logging are only asking about cohort 1; cohort 2 has no effect or role here.
                     // IF (((PreDisturbanceAge % (SOURCE PreDisturbanceAge) <=10)) AND (SppLookup[PreDisturbanceSpp , 0]  EQ l1))
                     IF (PreDisturbanceSpp EQ (SOURCE PreDisturbanceSpp))
                        LikeNeighbLoc[nLikeNeighbours] = Location
                        nLikeNeighbours = nLikeNeighbours + 1
                     END
                  END
   
                  IF nLikeNeighbours > 0
                     // Pick one to copy.
                     neighb = MIN(FLOOR(UNIFORM(0,nLikeNeighbours)), nLikeNeighbours-1)
                     AT LOCATION(LikeNeighbLoc[neighb])
                        usedNeighbourTraj = TRUE
                        SOURCE AU = AU
                        SOURCE Species = Species
                        // Clear previous trajectories
                        REMOVE ALL(SOURCE TransTrajectory)
                        SOURCE NumTrans = 0
                        p = HEAD(TransTrajectory)
                        WHILE(p)
                           singleTrans [=] GET(TransTrajectory, p)
                           p = NEXT(TransTrajectory,p)
                           // Add a new transition
                           INSERT TAIL(SOURCE TransTrajectory, singleTrans)
                           SOURCE NumTrans = SOURCE NumTrans + 1
                        END
                     END
                  END
               END
 
               // Eliminate second cohort successional trajectory for logging or fire disturbance
               REMOVE ALL(TransTrajectory2)

               // End spatially contagious succession
               // ######################################################################  
               // If we didn't use the spatially contiguous succession pick spp. from distribution in succession file
                            IF (!usedNeighbourTraj) 
                  OVER INDEX(1,NumSppCodes-1)
                     tmpLead = SppLookup[Index, 0]
                     tmpSecondary = SppLookup[Index, 1]
                      // This will use base probabilities (representation) for each landtype: no temporal contagion.
                     pTreeSppVector[Index] = pReceiveTransition[baseIndex,Index]
                  END
                  lastDisturbanceAgent = LastDisturbance

                  AU = MAX(AU - CLAMP(SppLookup[SppInv,3],0,10), 3)

	  IF (lastDisturbanceAgent EQ rFire)
                      Species = CLASSIFIED_DIST[pTreeSppVector]
                    END

                  // Clear previous trajectories (if they exist)
                  REMOVE ALL(TransTrajectory)
               END  // end !used NeighbTraj loop

            ELSE // for first time step
               Species = PreDisturbanceSpp
            END  //  end Time>0 loop
         
         END  // ##$$%%  End of SBWMortality loop

         SBWMortality = 0 //  reset tag for all so we don't go over it again. 

         // ###################################################################
         // ###   STEP # 4 --> Now generate trajectories!!
         // ###################################################################

         //$$ NEWPJ Oct 21/07 -- // Contagion for initial trajectories - Time =0
         IF (FLOOR(Time) <= 0) AND (pTrajContagion > 0) AND (UNIFORM(0,1) <= pTrajContagion)
            nLikeNeighbours = 0
            OVER REGION CENTRED(1,1)
               DECISION (Species > 0) AND (NumTrans > 0)  // is a spp. and has a trajectory assigned
                  // initial trajectories depend on spp/age intersection
                  IF ((Species EQ SOURCE Species) AND (StandAge EQ (SOURCE StandAge)))
                     LikeNeighbLoc[nLikeNeighbours] = Location
                     nLikeNeighbours = nLikeNeighbours + 1
                  END
               END
            IF nLikeNeighbours > 0
               neighb = MIN(FLOOR(UNIFORM(0,nLikeNeighbours)), nLikeNeighbours-1)
               AT LOCATION(LikeNeighbLoc[neighb])
                  usedNeighbourTraj = TRUE
                  SOURCE NumTrans = 0
                  p = HEAD(TransTrajectory)
                  WHILE(p)
                     singleTrans [=] GET(TransTrajectory, p)
                     p = NEXT(TransTrajectory,p)
                     // Add a new transition
                     INSERT TAIL(SOURCE TransTrajectory, singleTrans)
                     SOURCE NumTrans = SOURCE NumTrans + 1
                  END 
               END
            END
         END

         IF (!usedNeighbourTraj)  // If we didn't use the spatially contiguous code, generate new trajectories.

            // Seral succession: don't allow succession during transition period after a previous species shift
            // Create the series of transitions as a list.  Because we calculate CurrAC here, the effect of moving the 
            // species etc. around in response to SBW is that we just have to create the rest of the transitions, 
            // not a whole trajectory.

            CurrAC = MIN(FLOOR(StandAge/ACSize),NumAC-1)
            currSpp = Species

            transAge = 0 
            NumTrans = 0

            OVER INDEX(CurrAC+1,NumAC-1)
               ac = Index
               // Only make a change if the proportion of this Spp is in decline, and not first AC
               // Now it's not an annual trans. prob, but for the entire age class.
               IF (ac > 0) AND (pMakeTransition[baseIndex+ac,Species] > 0) AND (UNIFORM(0,1) <= (pMakeTransition[baseIndex+ac,Species]))
                  
                  OVER INDEX(1,NumSppCodes-1)
                     // This will use base probabilities (representation): no temporal contagion
                     // pTreeSppVector[Index] = pReceiveTransition[baseIndex + ac, Index]

                     // Don't permit transitions to self
                     IF (Index NEQ Species)
                        id = baseIndex + ac
                        pTreeSppVector[Index] = Q[id*NumSppCodes+Species,Index]
                     ELSE
                        pTreeSppVector[Index] = 0
                     END
                  END

                  // pick age at which trans occurs. Uniform in age class, but at least SeralTransitionYears from last
                  minTransAge = MAX(ac*ACSize, transAge + SeralTransitionYears)
                  transAge = ROUND(UNIFORM(minTransAge, (ac+1)*ACSize-1))

                  singleTrans[0] = transAge
                  singleTrans[1] = CLASSIFIED_DIST[pTreeSppVector]
     
                  // Add a new transition
                  INSERT TAIL(TransTrajectory, singleTrans)
                  NumTrans = NumTrans + 1
               END
            END
         END

         // Repeat the same steps for the second cohort
         IF (PctCohort2 > 0)

            baseIndex2 = SuccessionGroup * NumAC

            // Seral succession: don't allow succession during transition period after a previous species shift
            CurrAC = MIN(FLOOR(StandAge2/ACSize),NumAC-1)
            currSpp = Species2
            transAge = 0 
            NumTrans2 = 0

            OVER INDEX(CurrAC+1,NumAC-1)
               ac = Index
               // Only make a change if the proportion of this Spp is in decline, and not first AC
               // Now it's not an annual trans. prob, but for the entire age class.
               IF (ac > 0) AND (pMakeTransition2[baseIndex2+ac,Species2] > 0) AND (UNIFORM(0,1) <= (pMakeTransition2[baseIndex2+ac,Species2]))

                  OVER INDEX(1,NumSppCodes-1)
                     // This will use base probabilities (representation): no temporal contagion
                     // ** Don't permit transitions to self
                     IF (Index NEQ Species2)
                        id = baseIndex2 + ac
                        pTreeSppVector2[Index] = Q2[id*NumSppCodes+Species2,Index]  // PJ!!
                     ELSE
                        pTreeSppVector2[Index] = 0
                     END
                  END

                  // pick age at which trans occurs. Uniform in age class, but at least SeralTransitionYears from last
                  minTransAge = MAX(ac*ACSize, transAge + SeralTransitionYears)
                  transAge = ROUND(UNIFORM(minTransAge, (ac+1)*ACSize-1))
                  singleTrans2[0] = transAge
                  singleTrans2[1] = CLASSIFIED_DIST[pTreeSppVector]

                  // Add a new transition
                  INSERT TAIL(TransTrajectory2, singleTrans2)
                  NumTrans2 = NumTrans2 + 1

               END
            END
         END
         
         // ###########
         // Set up next transition - cohort1
         IF (SIZE(TransTrajectory) <= 0)
            NextTransAge = 0  // no transitions
            NextTransYr = 0
         ELSE
            singleTrans [=] GET HEAD(TransTrajectory)
            NextTransAge = singleTrans[0]
            NextTransYr = CLAMP(NextTransAge - StandAge, 0, 300)
         END
         
         // ###########
         // Set up next transition - cohort2
         IF (PctCohort2 > 0) AND (SIZE(TransTrajectory2) <= 0)
            NextTransAge2 = 0  // no transitions
            NextTransYr2 = 0
         ELSE
            singleTrans2 [=] GET HEAD(TransTrajectory2)
            NextTransAge2 = singleTrans2[0]
            NextTransYr2 = CLAMP(NextTransAge2 - StandAge2, 0, 300)
         END

      //##############################################################################################################
      // Other years: apply precomputed trajectory
      //##############################################################################################################

      ELSE IF ApplySppSuccession < 2
         IF (NextTransAge > 0) AND (StandAge >= NextTransAge)  // for cohort 1
            // Determine new species
            singleTrans [=] GET HEAD(TransTrajectory)
            REMOVE HEAD(TransTrajectory)
            NumTrans = MAX(0,NumTrans - 1)
            IF (PctCohort2 > 0) //AND (NextTransAge2 > 0) AND (StandAge2 >= NextTransAge2)
               prevLead1 = SppLookup[Species,  0]
               prevLead2 = SppLookup[Species2, 0]
               SppInv = IF PctCohort2 > 50 THEN SppCombine[prevLead2,prevLead1] 
                        ELSE SppCombine[prevLead1,prevLead2]
               AU = MAX(AU - CLAMP(SppLookup[SppInv,3],0,10), 3)
               Species = singleTrans[1]
               lead1 = SppLookup[Species,  0]
               lead2 = SppLookup[Species2,  0]
               SppInv = IF (PctCohort2 > 50) THEN SppCombine[lead2,lead1] 
                        ELSE SppCombine[lead1,lead2]

            ELSE  
               prevLead = SppLookup[Species,  0]
               AU = MAX(AU - CLAMP(SppLookup[Species,3],0,10),3)
               Species = singleTrans[1]
            END

            lead = SppLookup[Species, 0]
            NumSppTrans[prevLead, lead] = NumSppTrans[prevLead, lead] + 1
            NumSppTrans[0, lead] = NumSppTrans[0, lead] + 1
            NumSppTrans[prevLead, 0] = NumSppTrans[prevLead, 0] + 1

            // Set the pre-disturbance age to reflect "age of species shift"

            // set up next trans
            IF (SIZE(TransTrajectory) <= 0)
               NextTransAge = 0  // no transitions
               NextTransYr = 0
            ELSE
               singleTrans [=] GET HEAD(TransTrajectory)
               NextTransAge = singleTrans[0]
               NextTransYr = CLAMP(NextTransAge - StandAge, 0, 300)
            END
         END

         IF (PctCohort2 > 0)
            IF (NextTransAge2 > 0) AND (StandAge2 >= NextTransAge2)  // only transition cohort 2
               // Determine new species
               singleTrans2 [=] GET HEAD(TransTrajectory2)
               REMOVE HEAD(TransTrajectory2)
               NumTrans2 = MAX(0,NumTrans2 - 1)

               prevLead1 = SppLookup[Species,  0]
               prevLead2 = SppLookup[Species2, 0]
               SppInv = IF (PctCohort2 > 50) THEN SppCombine[prevLead2,prevLead1] 
                        ELSE SppCombine[prevLead1,prevLead2]

               AU = MAX(AU - CLAMP(SppLookup[SppInv,3],0,10), 3)
               Species2 = singleTrans2[1]

               lead1 = SppLookup[Species,  0]
               lead2 = SppLookup[Species2, 0]
               SppInv = IF PctCohort2 > 50 THEN SppCombine[lead2,lead1] 
                        ELSE SppCombine[lead1,lead2]

               // set up next trans
               IF (SIZE(TransTrajectory2) <= 0)
                   NextTransAge2 = 0  // no transitions
                   NextTransYr2 = 0
               ELSE
                  singleTrans2 [=] GET HEAD(TransTrajectory2)
                  NextTransAge2 = singleTrans2[0]
                  NextTransYr2 = CLAMP(NextTransAge2 - StandAge2, 0, 300)
               END
            END
         END
   
      END // ##
       //////////////////////////////////////////////////////////////////
      // In all cases....
      //////////////////////////////////////////////////////////////////
      // Track the species composition

      IF PctCohort2 > 0 
         l1 = SppLookup[Species,  0]
         l2 = SppLookup[Species2, 0]
         SppInv = IF PctCohort2 > 50 THEN SppCombine[l2,l1] 
                  ELSE SppCombine[l1,l2]
      ELSE
         SppInv = Species
      END 

      lead = SppLookup[SppInv, 0]
      StandType = SppLookup[SppInv, rStandType]

      SpeciesLeadBySG[lead, SuccessionGroup] = SpeciesLeadBySG[lead,SuccessionGroup] + 1
      SpeciesBySG[SppInv, SuccessionGroup] = SpeciesBySG[SppInv,SuccessionGroup] + 1

      IF LandUnit > 0
         SpeciesLeadByLU[lead, LandUnit] = SpeciesLeadByLU[lead,LandUnit] + 1
         SpeciesByLU[SppInv, LandUnit] = SpeciesByLU[SppInv,LandUnit] + 1
         StandTypeByLU[StandType,LandUnit] = StandTypeByLU[StandType,LandUnit] + 1
      END

   END


   PROBINIT = FALSE

ENDPI


TRANSITIONS = FALSE


