// Landscape event definition for growing stock/cell availability in the  43-02 landscape model
LSEVENT: GrowingStock

DEFINITIONS
   /////////////////////////////////////////////////
   // INPUT STATE - constants and parameters
   /////////////////////////////////////////////////
   GLOBAL CONSTANT: HaPerCell, MinYieldSalvagePerHa, MaxStandAge
   GLOBAL CONSTANT: NumAgeClasses, ACSize
   LAYER: StudyArea, AU

   GLOBAL VARIABLE: BaseTimestep // Base Time step (in years)
   GLOBAL CONSTANT: AUInfo[], rMHA

   GLOBAL VARIABLE: MHA_Override, ForestSizeByZone[]

   // AAC in hectares or m3, set up in intervals
   GLOBAL CONSTANT: AAC[], MaxAACDecade

   // Increase growth in IM by this... (in lieu of having volume tables)
   GLOBAL VARIABLE: IMGrowthIncreaseFactor

   // Length of time for greenup constraints (default: 15 years)
   GLOBAL VARIABLE: GreenupYears


   // Whether to use hard or soft adjacency
   // Prob. of logging in an adjacency buffer (set to zero for hard adjacency)
   GLOBAL VARIABLE: pLogInBuffer

   // The maximum distance from road for harvesting is assumed to be 2000m. Set higher (along with MinNoEffectDist2Rd) to remove access restrictions.
   GLOBAL VARIABLE: MaxDist2Road

   // Volume curves
   GLOBAL CONSTANT: VolTable[], MAITable[], MaxDecade

   // CONSTRAINTS for AC scenarios
   GLOBAL CONSTANT: AgeClassTargets[]
   GLOBAL VARIABLE: ACType
   GLOBAL CONSTANT: rACStrictLocal, rACStrictReserveOlder, rACProbabilistic

   /////////////////////////////////////////////////
   // INPUT STATE - INTERNAL (computed in initial state)
   /////////////////////////////////////////////////
   // Prob. of logging in an adjacency buffer (set to zero for hard adjacency)
   LOCAL: softAdj


   /////////////////////////////////////////////////
   // INPUT STATE - dynamic in other events
   /////////////////////////////////////////////////
   LAYER: StandAge, StandAge2, Species, Dist2ActiveRds, VolIncLoss1,VolIncLoss2
   LAYER: SalvageableVolume , PctCohort2,  SBWMortality  //!!! set in insect.lse as response to sbw
   //LAYER: LostIncYears 

   LAYER: ManagementZone, StandType
   GLOBAL CONSTANT: rIM, rAC, rPA, rStripCut, NumManagementZones

   // For strip cutting
   LAYER: Logged
   GLOBAL CONSTANT: MaxTimeSinceDisturbance
   GLOBAL VARIABLE: StripCutMinReentryInterval // Strip cutting parameters

   // For AC scenarios
   GLOBAL VARIABLE: SizeByYearZone[], SurplusByYear[], SizeByClassZone[], SurplusByAC[]
   LOCAL: DeficitByYear[MaxStandAge+1]

   /////////////////////////////////////////////////
   // OUTPUT STATE
   /////////////////////////////////////////////////
   LAYER: VolPerHa // in 10ths of a cubic metre
   GLOBAL CONSTANT: MaxVolPerHa, VolScale

   // Treatment tracking
   LAYER: PotentialTreatmentType
   GLOBAL CONSTANT: Unavailable, GreenBlock, SalvageBlock
   GLOBAL VARIABLE: NumCellsAvailable, GrowingStockByZone[]

   // Limiting Constraints
   GLOBAL CONSTANT: NumGSCategories, GSCategories[], lTotal, lAvailable, lMHA, lProtected, lDist, lAdjGreenup, lACReserve, lStripCutReserve
   LOCAL: Vol[NumGSCategories], Area[NumGSCategories]
   LOCAL: AreaLimited[NumGSCategories], AreaLimited2[NumGSCategories]

   LOCAL: VolByZone[NumManagementZones+1, NumGSCategories], AreaByZone[NumManagementZones+1, NumGSCategories]
   LOCAL: AreaLimitedByZone[NumManagementZones+1, NumGSCategories], AreaLimitedByZone2[NumManagementZones+1, NumGSCategories]

   OUTPUT VARIABLE: limitingConstraints = limitingConstraints.txt
   OUTPUT VARIABLE: growingStock = growingStock.txt
   OUTPUT VARIABLE: limitingConstraintsByZone = limitingConstraintsByZone.txt
   OUTPUT VARIABLE: growingStockByZone = growingStockByZone.txt
ENDDEF


INITIALSTATE
   // Set up prob. of soft adj.
   softAdj = (GreenupYears > 0) AND (pLogInBuffer > 0)

   // Set up starting volume per ha (straight look-up into volume yield table)

   OVER REGION WHOLE MAP
   DECISION (StudyArea > 0) AND (Species > 0) AND (AU > 0) AND (AUInfo[AU,rMHA] > 0)
      EffectiveAge =  IF (ManagementZone EQ rIM )THEN (StandAge * IMGrowthIncreaseFactor) ELSE MAX((StandAge -10),0) 
      // read from 1 category earlier.. makes it work!! don't know why!!  ok!

      // set age back one TS so probinit can fill in.

      decade = CLAMP(EffectiveAge/10,0,MaxDecade)
      lower = FLOOR(decade)
      upper = CEILING(decade)

      pLower = upper - decade

      TotalVolPerHa = pLower * VolTable[AU, lower] + (1-pLower) * VolTable[AU, upper]

      VolPerHa = ROUND(TotalVolPerHa*VolScale)
   END

   INITIALSTATE = 1
ENDIS


RETURNTIME
   // Output report at the end of the event (which is captured just before the next instance is scheduled)
   IF (Time > 0)
      OVER INDEX(0, NumGSCategories -1)
         OUTPUT(growingStock)
            Run: Run
            Year: ROUND(Time)
            CategoryId: Index
            Category: $GSCategories[Index]
            Vol: Vol[Index]
            Area: Area[Index]
         END

         gsType = Index
         OVER INDEX(1,NumManagementZones)
           DECISION ForestSizeByZone[Index] > 0
            OUTPUT(growingStockByZone)
               Run
               Year: ROUND(Time)
               MgmtZoneId: Index
               MgmtZone: $Index {ManagementZone}
               CategoryId: gsType
               Category: $GSCategories[gsType]
               Vol: VolByZone[Index,gsType]
               Area: AreaByZone[Index,gsType]
            END
         END
      END

      OVER INDEX(1, NumGSCategories -1)  // Don't include lTotal
         OUTPUT(limitingConstraints)
            Run
            Year: ROUND(Time)
            CategoryId: Index
            Category: $GSCategories[Index]
            NetArea: AreaLimited[Index]
            TotalArea: AreaLimited2[Index]
         END

         gsType = Index
         OVER INDEX(1,NumManagementZones)
           DECISION ForestSizeByZone[Index] > 0
            OUTPUT(limitingConstraintsByZone)
               Run: Run
               Year: ROUND(Time)
               MgmtZoneId: Index
               MgmtZone: $Index {ManagementZone}
               CategoryId: gsType
               Category: $GSCategories[gsType]
               NetArea: AreaLimitedByZone[Index,gsType]
               TotalArea: AreaLimitedByZone2[Index,gsType]
            END
         END
      END
   END

//   RETURNTIME = IF Time EQ 0 THEN 0.01 ELSE BaseTimestep
   RETURNTIME = IF Time EQ 0 THEN 0.11 ELSE BaseTimestep  // just after succession


   // Clear tracking variables
   NumCellsAvailable = 0

   Vol [=] 0
   Area [=] 0
   AreaLimited [=] 0
   AreaLimited2 [=] 0
   VolByZone [=] 0
   AreaByZone [=] 0
   AreaLimitedByZone [=] 0
   AreaLimitedByZone2 [=] 0

   GrowingStockByZone [=] 0

   // Compute AC targets
   applicableDecade = MIN(FLOOR(Time/10), MaxAACDecade)
   IF (ForestSizeByZone[rAC] > 0) AND ((ForestSizeByZone[rAC] > 0) AND (AAC[rAC, applicableDecade] > 0))
      // Determine recruitment reserve
      OVER INDEX(0,MaxStandAge)
         ageClass = MIN(FLOOR(Index/ACSize), NumAgeClasses-1)
         meetsTarget = SizeByYearZone[Index,rAC] - ((AgeClassTargets[ageClass] * ForestSizeByZone[rAC])/ACSize)

         // If the age class meets the target, set surplus
         IF (meetsTarget >= 0)
            SurplusByYear[Index] = meetsTarget
            DeficitByYear[Index] = 0
         // Otherwise the age class has a deficit
         ELSE
            SurplusByYear[Index] = 0
            DeficitByYear[Index] = -1 * meetsTarget
         END
      END

      // Determine recruitment reserve by age class
      OVER INDEX(0,NumAgeClasses-1)
         meetsTarget = SizeByClassZone[Index,rAC] - (AgeClassTargets[Index] * ForestSizeByZone[rAC])
         // If the age class meets the target, set surplus
         SurplusByAC[Index] = MAX(0,meetsTarget)
      END

      // Reserve local surplus in ages above/below within a distance of the age class
      IF (ACType NEQ rACStrictLocal) AND (ACType NEQ rACProbabilistic)
         i = 0
         OVER INDEX(0,MaxStandAge)
            j = Index
//            i = IF (ACType EQ rACStrictReserveOlder) THEN MAX(i,j+1)
//                ELSE MAX(i, j - ACSize + 1)
            i = MAX(i, j - ACSize + 1)
            IF DeficitByYear[j] > 0
               maxClass = IF (ACType EQ rACStrictReserveOlder) THEN j-1
                          ELSE MIN(MaxStandAge,j+ACSize-1)
               OVER INDEX(i, maxClass)
                  IF (DeficitByYear[j] > 0) AND (i < MaxStandAge)
                     r = MIN(DeficitByYear[j], SurplusByYear[i])
                     SurplusByYear[i] = SurplusByYear[i] - r
                     DeficitByYear[j] = DeficitByYear[j] - r
                     i = i + (SurplusByYear[i] EQ 0)
                  END
               END
            END
         END
      END
   END

   OVER REGION WHOLE MAP
   // Take care of volume loss if only cohort 1 was killed  (i.e., SBWMortality ==2)
   DECISION (SBWMortality == 2 )
      VolPerHa = (((PctCohort2)/100) * VolPerHa)
      //SBWMortality = 0
   END
ENDRT


// Only process productive forest cells
EVENTLOCATION
   STATIC REGION WHOLE MAP
     DECISION (StudyArea > 0)
ENDEL



// Process in any order (oldest first is no longer necessary; this is much more
// efficient since sorting of all cells is costly).
PROBINIT
   PROBINIT = (Species > 0) //(AU > 0) AND (AUInfo[AU,rMHA] > 0) // Process all cells in productive forest

  // don;t add extra volume at first timestep
  // EffectiveAge1 =  IF ManagementZone EQ rIM THEN StandAge * IMGrowthIncreaseFactor ELSE StandAge   
  // EffectiveAge2 =  IF ManagementZone EQ rIM THEN StandAge2 * IMGrowthIncreaseFactor ELSE StandAge2 

   EffectiveAge1 = StandAge   
   EffectiveAge2 = IF (PctCohort2 > 0) THEN (StandAge2) ELSE 0

   IF (AU > 0) AND (AUInfo[AU,rMHA] > 0) AND Time > 0.2

      lower1 = MAX (FLOOR((EffectiveAge1 - BaseTimestep) /10), 0) 
      lower2 = MAX (FLOOR((EffectiveAge2 - BaseTimestep) /10), 0) 

      upper1 = FLOOR(EffectiveAge1/10)
      upper2 = FLOOR(EffectiveAge2/10)

      pLower1 = 1- ((EffectiveAge1 % BaseTimestep)/BaseTimestep)
      pLower2 = 1- ((EffectiveAge2 % BaseTimestep)/BaseTimestep)

      // a and b represent coefficient to modify the amount of volume lost dependent on what cohorts the 
      // defoliation affected.  This is based on the SBWMortality layer: 1= both, 2= only 2nd, and 3= only 1st.
      // a = IF SBWMortality EQ 2 THEN 1 ELSE 0 

      //MAI.txt table is in m^3 per year. in this decade increment =0 m^3 /yr.
      IF (EffectiveAge1 < MaxStandAge )
          //VolInc1 = (BaseTimestep - (a *LostIncYears)) * ((pLower1 * MAITable[AU, lower1]) + ( (1-pLower1) * MAITable[AU, upper1]))
          VolInc1 = BaseTimestep * (((pLower1 * MAITable[AU, lower1]) + ( (1-pLower1) * MAITable[AU, upper1])))
      ELSE
          VolInc1 = 0  //  cease accruing volume at max age!!
      END

      IF (EffectiveAge2 < MaxStandAge) AND (EffectiveAge2 NEQ 0)
         //VolInc2 = (BaseTimestep - (a *LostIncYears)) * ((pLower2 * MAITable[AU, lower2]) + (1-pLower2) * MAITable[AU, upper2])
         VolInc2 = BaseTimestep * (((pLower2 * MAITable[AU, lower2]) + ((1-pLower2) * MAITable[AU, upper2])))
      ELSE 
         VolInc2 = 0  //  cease accruing volume at max age.
      END

      //SBW Losses to incrememnt
      // *******************************

      VolInc1 = IF (VolIncLoss1 >0) THEN (VolInc1 * (VolIncLoss1/100)) ELSE VolInc1
      VolInc2 = IF (VolIncLoss2 >0) THEN (VolInc2 * (VolIncLoss2/100)) ELSE VolInc2

      VolIncLoss1 = 0  //clear so we don't go over it again.
      VolIncLoss2 = 0  //clear so we don't go over it again.

      // *******************************
      TotalVolIncPerHa = (((100-PctCohort2)/100) * VolInc1) + ((PctCohort2/100) * VolInc2)
      VolPerHa = MIN(VolPerHa + (ROUND(TotalVolIncPerHa*VolScale )), MaxVolPerHa*100) // VolScale = 100
      Yield = CLAMP((VolPerHa/VolScale) * HaPerCell, 0, MaxVolPerHa)
  END

   // Step through zones and stratifications to determine available and constrained
   // areas and volumes
   PotentialTreatmentType = Unavailable
   Vol[lTotal] = Vol[lTotal] + Yield
   Area[lTotal] = Area[lTotal] + HaPerCell
   VolByZone[ManagementZone,lTotal] = VolByZone[ManagementZone,lTotal] + Yield
   AreaByZone[ManagementZone,lTotal] = AreaByZone[ManagementZone,lTotal] + HaPerCell
   GrowingStockByZone[ManagementZone] = GrowingStockByZone[ManagementZone] + Yield
// Could add in vol operable Yield = Yield * (pOperable)


   lConstraint = lAvailable

   inBuffer = FALSE
   InvEffAge = IF PctCohort2 > 50 THEN EffectiveAge2 ELSE EffectiveAge1

   IF (GreenupYears > 0)
      OVER REGION CENTRED(1, 1.5)
         inBuffer = inBuffer OR (InvEffAge <= GreenupYears)
      END
   END

   // First check minimum harvest age: don't use look ahead (even if enabled)  BUT: This is done in FSSIM
   //   isMature = (StandAge >= AUInfo[AU,rMHA])
   mha = IF (MHA_Override > 0) THEN MHA_Override ELSE AUInfo[AU,rMHA]

   isMature = (InvEffAge >= mha)

   IF isMature 
      Vol[lMHA] = Vol[lMHA] + Yield
      Area[lMHA] = Area[lMHA] + HaPerCell
      VolByZone[ManagementZone,lMHA] = VolByZone[ManagementZone,lMHA] + Yield
      AreaByZone[ManagementZone,lMHA] = AreaByZone[ManagementZone,lMHA] + HaPerCell
   ELSE
      lConstraint = lMHA
      AreaLimited2[lMHA] = AreaLimited2[lMHA] + HaPerCell
      AreaLimitedByZone2[ManagementZone,lMHA] = AreaLimitedByZone2[ManagementZone,lMHA] + HaPerCell
   END

   // Protected areas
   IF (ManagementZone EQ rPA)
      Vol[lProtected] = Vol[lProtected] + Yield
      Area[lProtected] = Area[lProtected] + HaPerCell
      VolByZone[ManagementZone,lProtected] = VolByZone[ManagementZone,lProtected] + Yield
      AreaByZone[ManagementZone,lProtected] = AreaByZone[ManagementZone,lProtected] + HaPerCell

      lConstraint = IF (lConstraint NEQ lAvailable) THEN lConstraint ELSE lProtected
      AreaLimited2[lProtected] = AreaLimited2[lProtected] + HaPerCell * (lConstraint NEQ lMHA)
      AreaLimitedByZone2[ManagementZone,lProtected] = AreaLimitedByZone2[ManagementZone,lProtected] + HaPerCell * (lConstraint NEQ lMHA)
   END

   // Accessible by road
   isAccessible = (Dist2ActiveRds <= MaxDist2Road)
   IF !isAccessible
      Vol[lDist] = Vol[lDist] + Yield
      Area[lDist] = Area[lDist] + HaPerCell
      VolByZone[ManagementZone,lDist] = VolByZone[ManagementZone,lDist] + Yield
      AreaByZone[ManagementZone,lDist] = AreaByZone[ManagementZone,lDist] + HaPerCell

      lConstraint = IF (lConstraint NEQ lAvailable) THEN lConstraint ELSE lDist
      AreaLimited2[lDist] = AreaLimited2[lDist] + HaPerCell * (lConstraint NEQ lMHA)
      AreaLimitedByZone2[ManagementZone,lDist] = AreaLimitedByZone2[ManagementZone,lDist] + HaPerCell * (lConstraint NEQ lMHA)
   END

   // Adjacency and greenup
   isNotInBuffer = ((softAdj) OR (!inBuffer))
   IF inBuffer
      Vol[lAdjGreenup] = Vol[lAdjGreenup] + Yield
      Area[lAdjGreenup] = Area[lAdjGreenup] + HaPerCell
      VolByZone[ManagementZone,lAdjGreenup] = VolByZone[ManagementZone,lAdjGreenup] + Yield
      AreaByZone[ManagementZone,lAdjGreenup] = AreaByZone[ManagementZone,lAdjGreenup] + HaPerCell

      lConstraint = IF (lConstraint NEQ lAvailable) OR (softAdj) THEN lConstraint ELSE lAdjGreenup
      AreaLimited2[lAdjGreenup] = AreaLimited2[lAdjGreenup] + HaPerCell * (lConstraint NEQ lMHA)
      AreaLimitedByZone2[ManagementZone,lAdjGreenup] = AreaLimitedByZone2[ManagementZone,lAdjGreenup] + HaPerCell * (lConstraint NEQ lMHA)
   END

   // AC-targeted reserves (strict only). Lock out: if the zone has exceeded it's age class target limits
   ageClass = MIN(FLOOR(InvEffAge / ACSize), NumAgeClasses-1)
   IF (ManagementZone EQ rAC) AND (ACType NEQ rACProbabilistic) AND ((SurplusByYear[InvEffAge ] <= 0) OR (SurplusByAC[ageClass] <= 0))
      Vol[lACReserve] = Vol[lACReserve] + Yield
      Area[lACReserve] = Area[lACReserve] + HaPerCell
      VolByZone[ManagementZone,lACReserve] = VolByZone[ManagementZone,lACReserve] + Yield
      AreaByZone[ManagementZone,lACReserve] = AreaByZone[ManagementZone,lACReserve] + HaPerCell

      lConstraint = IF (lConstraint NEQ lAvailable) THEN lConstraint ELSE lACReserve
      AreaLimited2[lACReserve] = AreaLimited2[lACReserve] + HaPerCell * (lConstraint NEQ lMHA)
      AreaLimitedByZone2[ManagementZone,lACReserve] = AreaLimitedByZone2[ManagementZone,lACReserve] + HaPerCell * (lConstraint NEQ lMHA)
   END

   // Strip cut re-entry reserves
/*DISPLAY
? (0 < Logged < 375) AND (isMature)
StripCutMinReentryInterval
cond:(ManagementZone EQ rStripCut) AND ((MaxTimeSinceDisturbance-Logged) < StripCutMinReentryInterval) AND (StandAge > StripCutMinReentryInterval)
StandAge
END
*/
   IF (ManagementZone EQ rStripCut) AND ((MaxTimeSinceDisturbance-Logged) < StripCutMinReentryInterval) AND (InvEffAge > StripCutMinReentryInterval)
      Vol[lStripCutReserve] = Vol[lStripCutReserve] + Yield
      Area[lStripCutReserve] = Area[lStripCutReserve] + HaPerCell
      VolByZone[ManagementZone,lStripCutReserve] = VolByZone[ManagementZone,lStripCutReserve] + Yield
      AreaByZone[ManagementZone,lStripCutReserve] = AreaByZone[ManagementZone,lStripCutReserve] + HaPerCell

      lConstraint = IF (lConstraint NEQ lAvailable) THEN lConstraint ELSE lStripCutReserve
      AreaLimited2[lStripCutReserve] = AreaLimited2[lStripCutReserve] + HaPerCell * (lConstraint NEQ lMHA)
      AreaLimitedByZone2[ManagementZone,lStripCutReserve] = AreaLimitedByZone2[ManagementZone,lStripCutReserve] + HaPerCell * (lConstraint NEQ lMHA)
   END


   // Finally: we know if this cell is available
   IF (lConstraint EQ lAvailable)
      Vol[lAvailable] = Vol[lAvailable] + Yield
      Area[lAvailable] = Area[lAvailable] + HaPerCell
      VolByZone[ManagementZone,lAvailable] = VolByZone[ManagementZone,lAvailable] + Yield
      AreaByZone[ManagementZone,lAvailable] = AreaByZone[ManagementZone,lAvailable] + HaPerCell
   END

   PotentialTreatmentType = IF (lConstraint EQ lAvailable) THEN GreenBlock
                            ELSE IF (SalvageableVolume >= MinYieldSalvagePerHa*HaPerCell) AND (Dist2ActiveRds <= MaxDist2Road) THEN SalvageBlock
                            ELSE Unavailable
   NumCellsAvailable = NumCellsAvailable + (PotentialTreatmentType > Unavailable)
   AreaLimited[lConstraint] = AreaLimited[lConstraint] + HaPerCell
   AreaLimitedByZone[ManagementZone,lConstraint] = AreaLimitedByZone[ManagementZone,lConstraint] + HaPerCell
ENDPI
