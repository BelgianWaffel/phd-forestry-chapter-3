// Landscape event definition for simple logging (version 2) in the case study model
// It is driven by the input variable AreaToCutPerYear, which specifies the area to cut per year.
// Enough cutblocks are laid down to cut the required area
LSEVENT: Logging

DEFINITIONS
   GLOBAL CONSTANT: HaPerCell, MaxBlockId

   /****************************************/
   // Parameters
   GLOBAL VARIABLE: BaseTimestep     // Base Time step (in years)
   GLOBAL VARIABLE: GreenupYears     // Time for greenup constraints (default: 20 years)
   GLOBAL VARIABLE: AreaToCutPerYear // Harvest rate in hectares
   GLOBAL VARIABLE: MinHarvestAge    // Min. harvest age in years
   GLOBAL VARIABLE: BlockSizeMin, BlockSizeMax // block size range

   GLOBAL VARIABLE: MaxDist2Rd      // The maximum distance from road for harvesting is assumed to be 2000m. Set higher (along with MinNoEffectDist2Rd) to remove access restrictions.
   GLOBAL VARIABLE: MinNoEffectDist2Rd // distance with no road effects (before effect starts to kick in)
    /****************************************/

   // Static and input layers
   LAYER: StudyArea
   LAYER: ForestStatus
      GLOBAL CONSTANT: Productive

   // Dynamic layers
   LAYER: StandAge, Logged // Time since logging is MaxTimeSinceDisturbance - Logged
   GLOBAL CONSTANT: MaxTimeSinceDisturbance

   LAYER: BlockId
   LOCAL: currBlockId

   LAYER: Dist2Road
   LOCAL: RdDistEffectSlope
 
   // Tracking variable
   GLOBAL VARIABLE: AreaHarvested // Area cut in year
   GLOBAL VARIABLE: BlkLandingLoc[], nBlocks // For indicating where roads are to be built

   // Event and cluster variables
   EVENT VARIABLE: HarvestTarget
   CLUSTER VARIABLE: BlockExtent
   CLUSTER VARIABLE: currBlockSize
ENDDEF


INITIALSTATE
   currBlockId = 0 // initialized local (non-spatial) variable on start up (these don't have defined initial values)

   // calculate slope of deline from 1 at MinNoEffectDist2Rd to 0 at MaxDist2Rd
   RdDistEffectSlope = IF (MaxDist2Rd > MinNoEffectDist2Rd) THEN 1 / (MinNoEffectDist2Rd - MaxDist2Rd) ELSE 0

   INITIALSTATE = 1 // start one instance on startup (default)s
ENDIS


// Run after fire (schedule the first instance at time 0.7, then each time step thereafter)
RETURNTIME
   RETURNTIME = IF Time EQ 0 THEN 0.7 ELSE BaseTimestep

   // Reset area harvested and number of blocks
   AreaHarvested = 0
   nBlocks = 0
ENDRT


// Only allow logging in forested cells in the THLB (defined in this simple case study as productive forest state)
EVENTLOCATION
   STATIC REGION WHOLE MAP
     DECISION (StudyArea > 0) AND (ForestStatus EQ Productive)

   Logged = MAX(Logged-BaseTimestep, 0) // update the Logged (reverse time since logging) layer
ENDEL


NUMCLUSTERS
   // Determine harvest target for entire time period
   HarvestTarget = AreaToCutPerYear * BaseTimestep

   // Keep logging (initiating block clusters) until the target is met or there are not more available cells
   NUMCLUSTERS = WHILE HarvestTarget > 0

   // Select target blok size for this cluster (block) from a uniform distribution
   BlockExtent = ROUND(UNIFORM(BlockSizeMin/HaPerCell, BlockSizeMax/HaPerCell))

   // Increment the current block id (a local variable is ok to use since blocks are placed sequentially - 
   // for parallel cluster spread,a cluster variable should be used since there may be more than one cluster active at a time)
   // The modulo (%) function is used to "rotate" block id's when the maximum id is reached
   currBlockId = (currBlockId % MaxBlockId) + 1

   currBlockSize = 0
ENDNC


// Process cells in sorted order from highet to lowest ProbInit (to pick the block initiations deterministically)
PROBINIT ORDERED
   // NOTE: ProbInit is computed at the start of the period and the probabilitieis do not reflect changes as harvesting progresses.
   // Hence, to avoid re-logging a cell, a check is made again in Transitions

   // Check if this cell in an ajacency buffer: look at the nearest neighbours
   inBuffer = FALSE
   IF (GreenupYears > 0)
      OVER REGION CENTRED(1, 1.5)
         DECISION (StudyArea > 0) AND (ForestStatus > 0)
         inBuffer = inBuffer OR (StandAge <= GreenupYears)
      END
   END

   // p is the relative likelihood of selecting a cell for block initiaton
   // defined in this event as the product of 5 factors
   p = PRODUCT
          // Minimum harvest age (Boolean or binary: go/no go)
          (StandAge >= MinHarvestAge)

         // Adjacency greenup (Boolean go/no go)
         !inBuffer

          // Accessible by road (Boolean go/no go)
          (Dist2Road <= MaxDist2Rd)

          // Relative oldest first (increasing with age)
          (StandAge - MinHarvestAge + 1)

          // Probability based on distance (decreasing with distance from road)
          IF Dist2Road <= MinNoEffectDist2Rd THEN 1 ELSE MAX(0,1 + (Dist2Road-MinNoEffectDist2Rd)*RdDistEffectSlope)
       END

   PROBINIT = p
ENDPI



TRANSITIONS
   // Check if we should still be logging.

   // There is still extent left in the block and area to harvest
   isAvailable = (BlockExtent >= 1) AND (HarvestTarget > 0)

   // Min. harvest age still met (this may fail on the first cell of a new block if it started in a previously logged cell)
   isAvailable = isAvailable AND (StandAge >= MinHarvestAge)

   // Check adjacency again (condiions may have changed from when ProbInit was calculated)
   inBuffer = FALSE
   IF (GreenupYears > 0)
      OVER REGION CENTRED(1, 1.5)
         DECISION (StudyArea > 0) AND (ForestStatus > 0)
         inBuffer = inBuffer OR ((StandAge <= GreenupYears) AND (BlockId NEQ currBlockId))
      END
   END
   isAvailable = isAvailable AND (!inBuffer)

   // Finally: we know if this cell is available for harvest - make a transition only cell is still available
   TRANSITIONS = isAvailable

   // In the context of logging:

   // If this is an initiating cell (curr size is 0): mark to later create a spur road
   // Do this test in Transitions instead of ProbInit because we know at this point that the cell will be logged
   IF (currBlockSize EQ 0)
      BlkLandingLoc[nBlocks] = Location
      nBlocks = nBlocks + 1
   END

   // Decrement the number of cells remaining to log for this block, and increment block size
   BlockExtent = BlockExtent - 1
   HarvestTarget = HarvestTarget - HaPerCell
   currBlockSize = currBlockSize + HaPerCell

   // Increment area harvested
   AreaHarvested = AreaHarvested + HaPerCell

   // Set the stand age to 0 and time since harvest to MaxTimeSinceDisturbance (reverse of time since fire - sometimes more convenient for visualizing)
   StandAge = 0
   Logged = MaxTimeSinceDisturbance
   BlockId = currBlockId
ENDTR


// Use immediate spread so that an entire block is processed before the next is initiated
// The difference between a SpreadTime of 0 and -1 is the following (neither consume simulation time):
//   SpreadTime 0: clusters for the event will all be processed in parallel (spreading will put active cells on the queue at the current time)
//   SpreadTime -1: once initiated, a cluster will fully spread before the next cluster initiates (i.e. clusters processed in sequence)
//     Internal to the cluster, this is the same as SpreadTime 0, but cluster initiation will pause until spreading is finished for the cluster
//  One use of negative SpreadTime is in conjunction with the "WHILE" option in NumClusters (to keep initiating clusters as long as a condition is met)
SPREADTIME = -1


// Spread to 4 cardinal neighbours in the THLB (keeps blocks more compact)
SPREADLOCATION
   REGION CENTRED(1,1)
      DECISION (StudyArea > 0) AND (ForestStatus EQ Productive)
ENDSL


// SpreadProb is not specified, which means use of the default of 1 (select all cells in the SpreadLocation)

